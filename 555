backend/routes/adminRoutes.js — to add the bulk share API endpoint

const express = require('express');
const router = express.Router();
const jwt = require('jsonwebtoken');
const Video = require('../models/Video');
const Category = require('../models/Category');
const Ad = require('../models/Ad');
const Report = require('../models/Report');

// Simple Admin Auth Middleware
const simpleAdminAuth = (req, res, next) => {
  try {
    const authHeader = req.headers.authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return res.status(401).json({ error: 'Access denied. No token provided.' });
    }
    const token = authHeader.split(' ')[1];
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    if (!decoded.isAdmin) {
      return res.status(401).json({ error: 'Invalid admin token.' });
    }
    req.admin = decoded;
    next();
  } catch (error) {
    if (error.name === 'JsonWebTokenError') {
      return res.status(401).json({ error: 'Invalid token.' });
    }
    if (error.name === 'TokenExpiredError') {
      return res.status(401).json({ error: 'Token expired.' });
    }
    res.status(500).json({ error: 'Authentication failed.' });
  }
};

// POST /api/admin/login
router.post('/login', (req, res) => {
  try {
    const { password, username } = req.body;
    
    if (password === process.env.ADMIN_PASSWORD) {
      const token = jwt.sign(
        { isAdmin: true, username: username || 'admin', loginTime: Date.now() },
        process.env.JWT_SECRET,
        { expiresIn: '24h' }
      );
      return res.json({
        success: true,
        token,
        admin: { username: username || 'admin', role: 'admin' },
        message: 'Login successful'
      });
    }
    res.status(401).json({ error: 'Invalid credentials' });
  } catch (error) {
    console.error('Login Error:', error);
    res.status(500).json({ error: 'Login failed' });
  }
});

// POST /api/admin/verify
router.post('/verify', simpleAdminAuth, (req, res) => {
  res.json({ success: true, admin: req.admin, message: 'Token is valid' });
});

// GET /api/admin/dashboard
router.get('/dashboard', simpleAdminAuth, async (req, res) => {
  try {
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const weekAgo = new Date(today.getTime() - 7 * 24 * 60 * 60 * 1000);

    const [totalVideos, publicVideos, totalViewsResult, totalCategories, totalAds, pendingReports, todayVideos, weekVideos] = await Promise.all([
      Video.countDocuments(),
      Video.countDocuments({ status: 'public' }),
      Video.aggregate([{ $group: { _id: null, total: { $sum: '$views' } } }]),
      Category.countDocuments({ isActive: true }),
      Ad.countDocuments({ enabled: true }),
      Report.countDocuments({ status: 'pending' }),
      Video.countDocuments({ uploadDate: { $gte: today } }),
      Video.countDocuments({ uploadDate: { $gte: weekAgo } })
    ]);

    const topVideos = await Video.find({ status: 'public' })
      .sort({ views: -1 })
      .limit(5)
      .select('title thumbnail views uploadDate');

    const recentUploads = await Video.find()
      .sort({ uploadDate: -1 })
      .limit(5)
      .select('title thumbnail views status uploadDate');

    res.json({
      success: true,
      stats: {
        totalVideos,
        publicVideos,
        totalViews: totalViewsResult[0]?.total || 0,
        totalCategories,
        totalAds,
        pendingReports,
        todayVideos,
        weekVideos
      },
      topVideos,
      recentUploads,
      viewsByDay: []
    });
  } catch (error) {
    console.error('Dashboard Error:', error);
    res.status(500).json({ error: 'Failed to get dashboard data' });
  }
});

// GET /api/admin/videos
router.get('/videos', simpleAdminAuth, async (req, res) => {
  try {
    const { page = 1, limit = 20, search = '', status = '', featured = '', sort = 'newest' } = req.query;
    const query = {};

    if (search) {
      query.$or = [
        { title: { $regex: search, $options: 'i' } },
        { file_code: { $regex: search, $options: 'i' } }
      ];
    }
    if (status) query.status = status;
    if (featured === 'true') query.featured = true;
    if (featured === 'false') query.featured = false;

    let sortOption = {};
    switch (sort) {
      case 'oldest': sortOption = { uploadDate: 1 }; break;
      case 'views': sortOption = { views: -1 }; break;
      case 'title': sortOption = { title: 1 }; break;
      default: sortOption = { uploadDate: -1 };
    }

    const skip = (parseInt(page) - 1) * parseInt(limit);
    const [videos, total] = await Promise.all([
      Video.find(query).populate('category', 'name slug').sort(sortOption).skip(skip).limit(parseInt(limit)),
      Video.countDocuments(query)
    ]);

    res.json({
      success: true,
      videos,
      pagination: { page: parseInt(page), limit: parseInt(limit), total, pages: Math.ceil(total / parseInt(limit)) }
    });
  } catch (error) {
    console.error('Get Videos Error:', error);
    res.status(500).json({ error: 'Failed to get videos' });
  }
});

// PUT /api/admin/videos/:id
router.put('/videos/:id', simpleAdminAuth, async (req, res) => {
  try {
    const { title, description, thumbnail, category, tags, status, featured, duration } = req.body;
    const video = await Video.findById(req.params.id);
    if (!video) return res.status(404).json({ error: 'Video not found' });

    if (title) video.title = title;
    if (description !== undefined) video.description = description;
    if (thumbnail) video.thumbnail = thumbnail;
    if (category !== undefined) video.category = category || null;
    if (tags) video.tags = Array.isArray(tags) ? tags : tags.split(',').map(t => t.trim());
    if (status) video.status = status;
    if (featured !== undefined) video.featured = featured;
    if (duration) video.duration = duration;

    await video.save();
    res.json({ success: true, video, message: 'Video updated successfully' });
  } catch (error) {
    console.error('Update Video Error:', error);
    res.status(500).json({ error: 'Failed to update video' });
  }
});

// DELETE /api/admin/videos/:id
router.delete('/videos/:id', simpleAdminAuth, async (req, res) => {
  try {
    const video = await Video.findByIdAndDelete(req.params.id);
    if (!video) return res.status(404).json({ error: 'Video not found' });
    res.json({ success: true, message: 'Video deleted successfully' });
  } catch (error) {
    console.error('Delete Video Error:', error);
    res.status(500).json({ error: 'Failed to delete video' });
  }
});

// POST /api/admin/videos/bulk-delete
router.post('/videos/bulk-delete', simpleAdminAuth, async (req, res) => {
  try {
    const { ids } = req.body;
    if (!ids || !Array.isArray(ids) || ids.length === 0) {
      return res.status(400).json({ error: 'No video IDs provided' });
    }
    const result = await Video.deleteMany({ _id: { $in: ids } });
    res.json({ success: true, deletedCount: result.deletedCount, message: `${result.deletedCount} videos deleted` });
  } catch (error) {
    console.error('Bulk Delete Error:', error);
    res.status(500).json({ error: 'Failed to delete videos' });
  }
});

// PUT /api/admin/videos/:id/feature
router.put('/videos/:id/feature', simpleAdminAuth, async (req, res) => {
  try {
    const video = await Video.findById(req.params.id);
    if (!video) return res.status(404).json({ error: 'Video not found' });
    video.featured = !video.featured;
    await video.save();
    res.json({ success: true, featured: video.featured, message: video.featured ? 'Video featured' : 'Video unfeatured' });
  } catch (error) {
    console.error('Toggle Feature Error:', error);
    res.status(500).json({ error: 'Failed to toggle featured status' });
  }
});

// PUT /api/admin/videos/:id/status
router.put('/videos/:id/status', simpleAdminAuth, async (req, res) => {
  try {
    const { status } = req.body;
    if (!['public', 'private', 'unlisted'].includes(status)) {
      return res.status(400).json({ error: 'Invalid status' });
    }
    const video = await Video.findByIdAndUpdate(req.params.id, { status }, { new: true });
    if (!video) return res.status(404).json({ error: 'Video not found' });
    res.json({ success: true, status: video.status, message: 'Video status updated' });
  } catch (error) {
    console.error('Update Status Error:', error);
    res.status(500).json({ error: 'Failed to update status' });
  }
});

module.exports = router;

frontend/src/pages/admin/VideosManager.jsx — to add the bulk share UI

import React, { useState, useEffect, useCallback } from 'react';
import { Link } from 'react-router-dom';
import { 
  FiSearch, FiFilter, FiEdit2, FiTrash2, FiStar, 
  FiEye, FiMoreVertical, FiCheck, FiX, FiPlus 
} from 'react-icons/fi';
import toast from 'react-hot-toast';
import { adminAPI } from '../../services/api';
import AdminLayout from '../../components/admin/AdminLayout';
import Pagination from '../../components/common/Pagination';
import LoadingSpinner from '../../components/common/LoadingSpinner';
import { formatViews, formatDate, debounce } from '../../utils/helpers';

const VideosManager = () => {
  const [videos, setVideos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [pagination, setPagination] = useState({ page: 1, pages: 1, total: 0 });
  const [selectedVideos, setSelectedVideos] = useState([]);
  const [editingVideo, setEditingVideo] = useState(null);
  
  // Filters
  const [search, setSearch] = useState('');
  const [status, setStatus] = useState('');
  const [featured, setFeatured] = useState('');
  const [sort, setSort] = useState('newest');
  const [page, setPage] = useState(1);

  const fetchVideos = useCallback(async () => {
    setLoading(true);
    try {
      const response = await adminAPI.getVideos({
        page,
        limit: 20,
        search,
        status,
        featured,
        sort,
      });
      if (response.data.success) {
        setVideos(response.data.videos);
        setPagination(response.data.pagination);
      }
    } catch (error) {
      console.error('Failed to fetch videos:', error);
      toast.error('Failed to load videos');
    } finally {
      setLoading(false);
    }
  }, [page, search, status, featured, sort]);

  useEffect(() => {
    fetchVideos();
  }, [fetchVideos]);

  // Debounced search
  const debouncedSearch = debounce((value) => {
    setSearch(value);
    setPage(1);
  }, 500);

  const handleToggleFeatured = async (video) => {
    try {
      const response = await adminAPI.toggleFeatured(video._id);
      if (response.data.success) {
        setVideos(videos.map(v => 
          v._id === video._id ? { ...v, featured: response.data.featured } : v
        ));
        toast.success(response.data.message);
      }
    } catch (error) {
      toast.error('Failed to update featured status');
    }
  };

  const handleDelete = async (video) => {
    if (!window.confirm(`Delete "${video.title}"? This cannot be undone.`)) return;

    try {
      await adminAPI.deleteVideo(video._id);
      setVideos(videos.filter(v => v._id !== video._id));
      toast.success('Video deleted successfully');
    } catch (error) {
      toast.error('Failed to delete video');
    }
  };

  const handleBulkDelete = async () => {
    if (selectedVideos.length === 0) return;
    if (!window.confirm(`Delete ${selectedVideos.length} videos? This cannot be undone.`)) return;

    try {
      await adminAPI.bulkDeleteVideos(selectedVideos);
      setVideos(videos.filter(v => !selectedVideos.includes(v._id)));
      setSelectedVideos([]);
      toast.success(`${selectedVideos.length} videos deleted`);
    } catch (error) {
      toast.error('Failed to delete videos');
    }
  };

  const handleSelectAll = (e) => {
    if (e.target.checked) {
      setSelectedVideos(videos.map(v => v._id));
    } else {
      setSelectedVideos([]);
    }
  };

  const handleSelectVideo = (videoId) => {
    setSelectedVideos(prev => 
      prev.includes(videoId)
        ? prev.filter(id => id !== videoId)
        : [...prev, videoId]
    );
  };

  return (
    <AdminLayout title="Videos Manager">
      {/* Actions Bar */}
      <div className="bg-dark-200 rounded-xl p-4 mb-6 border border-dark-100">
        <div className="flex flex-col lg:flex-row gap-4">
          {/* Search */}
          <div className="flex-1 relative">
            <FiSearch className="absolute left-3 top-1/2 -translate-y-1/2 text-gray-500" />
            <input
              type="text"
              placeholder="Search videos..."
              onChange={(e) => debouncedSearch(e.target.value)}
              className="w-full pl-10 pr-4 py-2.5 bg-dark-100 border border-dark-100 rounded-lg focus:outline-none focus:ring-2 focus:ring-primary-500 text-white"
            />
          </div>

          {/* Filters */}
          <div className="flex gap-3">
            <select
              value={status}
              onChange={(e) => { setStatus(e.target.value); setPage(1); }}
              className="px-4 py-2.5 bg-dark-100 border border-dark-100 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <option value="">All Status</option>
              <option value="public">Public</option>
              <option value="private">Private</option>
              <option value="unlisted">Unlisted</option>
            </select>

            <select
              value={featured}
              onChange={(e) => { setFeatured(e.target.value); setPage(1); }}
              className="px-4 py-2.5 bg-dark-100 border border-dark-100 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <option value="">All Videos</option>
              <option value="true">Featured</option>
              <option value="false">Not Featured</option>
            </select>

            <select
              value={sort}
              onChange={(e) => { setSort(e.target.value); setPage(1); }}
              className="px-4 py-2.5 bg-dark-100 border border-dark-100 rounded-lg text-white focus:outline-none focus:ring-2 focus:ring-primary-500"
            >
              <option value="newest">Newest</option>
              <option value="oldest">Oldest</option>
              <option value="views">Most Viewed</option>
              <option value="title">Title A-Z</option>
            </select>
          </div>

          {/* Add Button */}
          <Link to="/admin/upload" className="btn-primary">
            <FiPlus className="w-5 h-5" />
            <span className="hidden sm:inline">Add Video</span>
          </Link>
        </div>

        {/* Bulk Actions */}
        {selectedVideos.length > 0 && (
          <div className="mt-4 flex items-center gap-4 pt-4 border-t border-dark-100">
            <span className="text-gray-400">
              {selectedVideos.length} selected
            </span>
            <button
              onClick={handleBulkDelete}
              className="px-4 py-2 bg-red-500/10 text-red-500 hover:bg-red-500/20 rounded-lg transition-colors"
            >
              <FiTrash2 className="w-4 h-4 inline mr-2" />
              Delete Selected
            </button>
          </div>
        )}
      </div>

      {/* Videos Table */}
      <div className="bg-dark-200 rounded-xl border border-dark-100 overflow-hidden">
        {loading ? (
          <LoadingSpinner />
        ) : videos.length === 0 ? (
          <div className="text-center py-12">
            <p className="text-gray-400">No videos found</p>
          </div>
        ) : (
          <div className="overflow-x-auto">
            <table className="w-full">
              <thead className="bg-dark-300">
                <tr>
                  <th className="px-4 py-3 text-left">
                    <input
                      type="checkbox"
                      onChange={handleSelectAll}
                      checked={selectedVideos.length === videos.length}
                      className="rounded"
                    />
                  </th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">Video</th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">Views</th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">Status</th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">Featured</th>
                  <th className="px-4 py-3 text-left text-sm font-medium text-gray-400">Date</th>
                  <th className="px-4 py-3 text-right text-sm font-medium text-gray-400">Actions</th>
                </tr>
              </thead>
              <tbody>
                {videos.map((video) => (
                  <tr key={video._id} className="border-t border-dark-100 hover:bg-dark-100/50 transition-colors">
                    <td className="px-4 py-3">
                      <input
                        type="checkbox"
                        checked={selectedVideos.includes(video._id)}
                        onChange={() => handleSelectVideo(video._id)}
                        className="rounded"
                      />
                    </td>
                    <td className="px-4 py-3">
                      <div className="flex items-center gap-3">
                        <img
                          src={video.thumbnail}
                          alt={video.title}
                          className="w-24 h-14 object-cover rounded"
                        />
                        <div className="min-w-0">
                          <p className="text-white font-medium truncate max-w-xs">{video.title}</p>
                          <p className="text-gray-500 text-sm">{video.file_code}</p>
                        </div>
                      </div>
                    </td>
                    <td className="px-4 py-3">
                      <span className="flex items-center gap-1 text-gray-300">
                        <FiEye className="w-4 h-4" />
                        {formatViews(video.views)}
                      </span>
                    </td>
                    <td className="px-4 py-3">
                      <span className={`badge ${
                        video.status === 'public' ? 'badge-success' :
                        video.status === 'private' ? 'badge-danger' : 'badge-warning'
                      }`}>
                        {video.status}
                      </span>
                    </td>
                    <td className="px-4 py-3">
                      <button
                        onClick={() => handleToggleFeatured(video)}
                        className={`p-2 rounded-lg transition-colors ${
                          video.featured
                            ? 'bg-yellow-500/20 text-yellow-500'
                            : 'bg-dark-100 text-gray-500 hover:text-yellow-500'
                        }`}
                      >
                        <FiStar className="w-5 h-5" fill={video.featured ? 'currentColor' : 'none'} />
                      </button>
                    </td>
                    <td className="px-4 py-3 text-gray-400 text-sm">
                      {formatDate(video.uploadDate)}
                    </td>
                    <td className="px-4 py-3">
                      <div className="flex items-center justify-end gap-2">
                        <button
                          onClick={() => setEditingVideo(video)}
                          className="p-2 hover:bg-dark-100 rounded-lg text-gray-400 hover:text-white transition-colors"
                        >
                          <FiEdit2 className="w-4 h-4" />
                        </button>
                        <button
                          onClick={() => handleDelete(video)}
                          className="p-2 hover:bg-red-500/10 rounded-lg text-gray-400 hover:text-red-500 transition-colors"
                        >
                          <FiTrash2 className="w-4 h-4" />
                        </button>
                      </div>
                    </td>
                  </tr>
                ))}
              </tbody>
            </table>
          </div>
        )}

        {/* Pagination */}
        <div className="p-4 border-t border-dark-100">
          <Pagination
            currentPage={pagination.page}
            totalPages={pagination.pages}
            onPageChange={setPage}
          />
        </div>
      </div>

      {/* Edit Modal */}
      {editingVideo && (
        <EditVideoModal
          video={editingVideo}
          onClose={() => setEditingVideo(null)}
          onSave={(updatedVideo) => {
            setVideos(videos.map(v => v._id === updatedVideo._id ? updatedVideo : v));
            setEditingVideo(null);
            toast.success('Video updated successfully');
          }}
        />
      )}
    </AdminLayout>
  );
};

// Edit Video Modal
const EditVideoModal = ({ video, onClose, onSave }) => {
  const [formData, setFormData] = useState({
    title: video.title || '',
    description: video.description || '',
    tags: video.tags?.join(', ') || '',
    status: video.status || 'public',
    featured: video.featured || false,
  });
  const [loading, setLoading] = useState(false);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);

    try {
      const response = await adminAPI.updateVideo(video._id, {
        ...formData,
        tags: formData.tags.split(',').map(t => t.trim()).filter(Boolean),
      });
      if (response.data.success) {
        onSave(response.data.video);
      }
    } catch (error) {
      toast.error('Failed to update video');
    } finally {
      setLoading(false);
    }
  };

  return (
    <div className="fixed inset-0 bg-black/50 flex items-center justify-center z-50 p-4">
      <div className="bg-dark-200 rounded-xl max-w-2xl w-full max-h-[90vh] overflow-y-auto">
        <div className="flex items-center justify-between p-6 border-b border-dark-100">
          <h3 className="text-lg font-semibold text-white">Edit Video</h3>
          <button onClick={onClose} className="p-2 hover:bg-dark-100 rounded-lg">
            <FiX className="w-5 h-5 text-gray-400" />
          </button>
        </div>

        <form onSubmit={handleSubmit} className="p-6 space-y-4">
          {/* Thumbnail Preview */}
          <div className="flex gap-4">
            <img
              src={video.thumbnail}
              alt={video.title}
              className="w-40 h-24 object-cover rounded-lg"
            />
            <div className="flex-1">
              <p className="text-gray-400 text-sm mb-1">File Code</p>
              <p className="text-white font-mono">{video.file_code}</p>
            </div>
          </div>

          {/* Title */}
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">Title</label>
            <input
              type="text"
              value={formData.title}
              onChange={(e) => setFormData({ ...formData, title: e.target.value })}
              className="input-field"
              required
            />
          </div>

          {/* Description */}
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">Description</label>
            <textarea
              value={formData.description}
              onChange={(e) => setFormData({ ...formData, description: e.target.value })}
              rows={4}
              className="input-field resize-none"
            />
          </div>

          {/* Tags */}
          <div>
            <label className="block text-sm font-medium text-gray-300 mb-2">Tags (comma separated)</label>
            <input
              type="text"
              value={formData.tags}
              onChange={(e) => setFormData({ ...formData, tags: e.target.value })}
              className="input-field"
              placeholder="tag1, tag2, tag3"
            />
          </div>

          {/* Status & Featured */}
          <div className="grid grid-cols-2 gap-4">
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">Status</label>
              <select
                value={formData.status}
                onChange={(e) => setFormData({ ...formData, status: e.target.value })}
                className="input-field"
              >
                <option value="public">Public</option>
                <option value="private">Private</option>
                <option value="unlisted">Unlisted</option>
              </select>
            </div>
            <div>
              <label className="block text-sm font-medium text-gray-300 mb-2">Featured</label>
              <label className="flex items-center gap-3 p-3 bg-dark-100 rounded-lg cursor-pointer">
                <input
                  type="checkbox"
                  checked={formData.featured}
                  onChange={(e) => setFormData({ ...formData, featured: e.target.checked })}
                  className="rounded"
                />
                <span className="text-gray-300">Featured on homepage</span>
              </label>
            </div>
          </div>

          {/* Buttons */}
          <div className="flex gap-3 pt-4">
            <button type="button" onClick={onClose} className="flex-1 btn-secondary">
              Cancel
            </button>
            <button type="submit" disabled={loading} className="flex-1 btn-primary">
              {loading ? 'Saving...' : 'Save Changes'}
            </button>
          </div>
        </form>
      </div>
    </div>
  );
};

export default VideosManager;

frontend/src/services/api.js — (I already have this, but confirm it hasn't changed)

import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || "https://api.xmaster.guru/api";


// Create axios instance
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('adminToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('adminToken');
      // Only redirect if on admin page
      if (window.location.pathname.startsWith('/admin')) {
        window.location.href = '/xmaster-admin';
      }
    }
    return Promise.reject(error);
  }
);

// ==================== PUBLIC API ====================

export const publicAPI = {
  // Home data
  getHomeData: () => api.get('/public/home'),
  
  // Videos
  getVideos: (params) => api.get('/videos', { params }),
  getVideo: (id) => api.get(`/videos/${id}`),
  getLatestVideos: (limit = 12) => api.get('/videos/latest', { params: { limit } }),
  getTrendingVideos: (limit = 12, period = '7d') => 
    api.get('/videos/trending', { params: { limit, period } }),
  getFeaturedVideos: (limit = 6) => api.get('/videos/featured', { params: { limit } }),
  getRelatedVideos: (id, limit = 10) => api.get(`/videos/${id}/related`, { params: { limit } }),
  getRandomVideos: (limit = 10, exclude = '') => 
    api.get('/videos/random', { params: { limit, exclude } }),
  
  // Video actions
  recordView: (id, sessionId) => api.post(`/videos/${id}/view`, { sessionId }),
  likeVideo: (id) => api.post(`/videos/${id}/like`),
  dislikeVideo: (id) => api.post(`/videos/${id}/dislike`),
  reportVideo: (id, data) => api.post(`/videos/${id}/report`, data),
  
  // Categories
  getCategories: () => api.get('/categories'),
  getCategory: (slug) => api.get(`/categories/${slug}`),
  getCategoryVideos: (slug, params) => api.get(`/categories/${slug}/videos`, { params }),
  
  // Search
  searchVideos: (params) => api.get('/search', { params }),
  getSearchSuggestions: (q) => api.get('/search/suggestions', { params: { q } }),
  searchByTag: (tag, params) => api.get(`/search/tags/${tag}`, { params }),
  getPopularTags: (limit = 20) => api.get('/search/popular-tags', { params: { limit } }),
  
  // Ads
  getAds: (device = 'desktop') => api.get('/ads', { params: { device } }),
  getAdByPlacement: (placement, device = 'desktop') => 
    api.get(`/ads/placement/${placement}`, { params: { device } }),
  recordAdImpression: (id) => api.post(`/ads/${id}/impression`),
  recordAdClick: (id) => api.post(`/ads/${id}/click`),
  
  // Stats
  getPublicStats: () => api.get('/public/stats'),


  // Comments
  getPublicComments: (page = 1, limit = 20) =>
    api.get('/comments/public', { params: { page, limit } }),
  submitComment: (data) => api.post('/comments', data),


    // Share tracking
  trackShare: (id, platform) => api.post(`/public/share/${id}/track`, { platform }),
  
  // Share debug (for testing)
  getShareDebug: (id) => api.get(`/public/share/${id}/debug`),

};

// ==================== ADMIN API ====================

export const adminAPI = {
  // Auth
  login: (password, username = 'admin') => 
    api.post('/admin/login', { password, username }),
  verifyToken: () => api.post('/admin/verify'),
  changePassword: (currentPassword, newPassword) => 
    api.post('/admin/change-password', { currentPassword, newPassword }),
  
  // Dashboard
  getDashboard: () => api.get('/admin/dashboard'),
  
  // Videos
  getVideos: (params) => api.get('/admin/videos', { params }),
  getVideo: (id) => api.get(`/admin/videos/${id}`),
  updateVideo: (id, data) => api.put(`/admin/videos/${id}`, data),
  deleteVideo: (id) => api.delete(`/admin/videos/${id}`),
  bulkDeleteVideos: (ids) => api.post('/admin/videos/bulk-delete', { ids }),
  toggleFeatured: (id) => api.put(`/admin/videos/${id}/feature`),
  updateVideoStatus: (id, status) => api.put(`/admin/videos/${id}/status`, { status }),
  
  // Upload
  uploadVideo: (formData, onProgress) => 
    api.post('/upload/single', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (e) => onProgress && onProgress(Math.round((e.loaded * 100) / e.total)),
    }),
  addByFileCode: (data) => api.post('/upload/file-code', data),
  bulkAddFileCodes: (videos) => api.post('/upload/bulk-file-codes', { videos }),
  uploadThumbnail: (formData) => 
    api.post('/upload/thumbnail', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    }),
  remoteUpload: (url, title, category, tags) => 
    api.post('/upload/url', { url, title, category, tags }),
  getAbyssFiles: (page = 1, limit = 50) => 
    api.get('/upload/abyss-files', { params: { page, limit } }),
  getAccountInfo: () => api.get('/upload/account-info'),
  
  // Categories
  createCategory: (data) => api.post('/categories', data),
  updateCategory: (id, data) => api.put(`/categories/${id}`, data),
  deleteCategory: (id) => api.delete(`/categories/${id}`),
  reorderCategories: (order) => api.put('/categories/admin/reorder', { order }),
  
  // Ads
  getAllAds: () => api.get('/ads/admin/all'),
  getAdPlacements: () => api.get('/ads/admin/placements'),
  createAd: (data) => api.post('/ads', data),
  updateAd: (id, data) => api.put(`/ads/${id}`, data),
  deleteAd: (id) => api.delete(`/ads/${id}`),
  toggleAd: (id) => api.put(`/ads/${id}/toggle`),
  
  // Analytics
  getAnalyticsDashboard: () => api.get('/analytics/dashboard'),
  getViewAnalytics: (period = '7d') => api.get('/analytics/views', { params: { period } }),
  getTopVideos: (limit = 10, period = '7d') => 
    api.get('/analytics/top-videos', { params: { limit, period } }),
  getCategoryAnalytics: () => api.get('/analytics/categories'),
  getAdAnalytics: () => api.get('/analytics/ads'),
  
  // Reports
  getReports: (params) => api.get('/analytics/reports', { params }),
  updateReport: (id, data) => api.put(`/analytics/reports/${id}`, data),


    // Comments
  getComments: (params) => api.get('/comments/admin', { params }),
  toggleCommentVisibility: (id) => api.put(`/comments/${id}/toggle-visibility`),
  markCommentRead: (id) => api.put(`/comments/${id}/read`),
  addCommentNote: (id, note) => api.put(`/comments/${id}/note`, { note }),
  deleteComment: (id) => api.delete(`/comments/${id}`),
  bulkDeleteComments: (ids) => api.post('/comments/bulk-delete', { ids }),


    // Duplicates
  getDuplicates: (params) => api.get('/duplicates', { params }),
  scanDuplicates: () => api.post('/duplicates/scan'),
  checkDuplicate: (data) => api.post('/duplicates/check', data),
  keepDuplicate: (id) => api.put(`/duplicates/${id}/keep`),
  makePublicDuplicate: (id) => api.put(`/duplicates/${id}/make-public`),
  deleteDuplicate: (id) => api.delete(`/duplicates/${id}`),
  bulkDeleteDuplicates: (ids) => api.post('/duplicates/bulk-delete', { ids }),
  clearAllDuplicates: () => api.post('/duplicates/clear-all'),
};



export default api;

frontend/src/pages/admin/UploadPage.jsx — to see the current upload UI and progress bar

import React, { useState, useEffect, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { 
  FiUploadCloud, FiFile, FiX, FiCheck, FiAlertCircle, 
  FiRefreshCw, FiPlay, FiPause, FiPlus, FiLink 
} from 'react-icons/fi';
import toast from 'react-hot-toast';
import { adminAPI, publicAPI } from '../../services/api';
import AdminLayout from '../../components/admin/AdminLayout';
import LoadingSpinner from '../../components/common/LoadingSpinner';

const UploadPage = () => {
  const [activeTab, setActiveTab] = useState('upload'); // upload, file-code, abyss-files
  const [categories, setCategories] = useState([]);
  
  // Fetch categories
  useEffect(() => {
    publicAPI.getCategories()
      .then(res => {
        if (res.data.success) {
          setCategories(res.data.categories);
        }
      })
      .catch(console.error);
  }, []);

  const tabs = [
    { id: 'upload', label: 'Upload Videos', icon: FiUploadCloud },
    { id: 'file-code', label: 'Add by File Code', icon: FiLink },
    { id: 'abyss-files', label: 'Import from Abyss', icon: FiFile },
  ];

  return (
    <AdminLayout title="Upload Videos">
      {/* Tabs */}
      <div className="bg-dark-200 rounded-xl border border-dark-100 mb-6">
        <div className="flex border-b border-dark-100">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex items-center gap-2 px-6 py-4 font-medium transition-colors ${
                activeTab === tab.id
                  ? 'text-primary-500 border-b-2 border-primary-500'
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              <tab.icon className="w-5 h-5" />
              {tab.label}
            </button>
          ))}
        </div>

        <div className="p-6">
          {activeTab === 'upload' && <BulkUploadSection categories={categories} />}
          {activeTab === 'file-code' && <FileCodeSection categories={categories} />}
          {activeTab === 'abyss-files' && <AbyssFilesSection categories={categories} />}
        </div>
      </div>
    </AdminLayout>
  );
};

// ==================== BULK UPLOAD SECTION ====================
const BulkUploadSection = ({ categories }) => {
  const [queue, setQueue] = useState([]);
  const [isUploading, setIsUploading] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [defaultCategory, setDefaultCategory] = useState('');
  const [defaultStatus, setDefaultStatus] = useState('public');

  const onDrop = useCallback((acceptedFiles) => {
    const newFiles = acceptedFiles.map(file => ({
      id: Math.random().toString(36).substr(2, 9),
      file,
      name: file.name,
      title: file.name.replace(/\.[^/.]+$/, '').replace(/[-_]/g, ' '),
      size: file.size,
      status: 'pending', // pending, uploading, success, failed
      progress: 0,
      error: null,
      category: defaultCategory,
      videoStatus: defaultStatus,
    }));
    setQueue(prev => [...prev, ...newFiles]);
  }, [defaultCategory, defaultStatus]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'video/*': ['.mp4', '.mkv', '.avi', '.mov', '.webm', '.flv']
    },
    multiple: true,
  });

  const updateQueueItem = (id, updates) => {
    setQueue(prev => prev.map(item => 
      item.id === id ? { ...item, ...updates } : item
    ));
  };

  const removeFromQueue = (id) => {
    setQueue(prev => prev.filter(item => item.id !== id));
  };

  const startUpload = async () => {
    if (queue.length === 0) return;
    
    setIsUploading(true);
    setIsPaused(false);

    for (let i = currentIndex; i < queue.length; i++) {
      if (isPaused) {
        setCurrentIndex(i);
        return;
      }

      const item = queue[i];
      if (item.status === 'success') continue;

      updateQueueItem(item.id, { status: 'uploading', progress: 0 });

      try {
        const formData = new FormData();
        formData.append('video', item.file);
        formData.append('title', item.title);
        formData.append('status', item.videoStatus);
        if (item.category) formData.append('category', item.category);

        await adminAPI.uploadVideo(formData, (progress) => {
          updateQueueItem(item.id, { progress });
        });

        updateQueueItem(item.id, { status: 'success', progress: 100 });
        toast.success(`Uploaded: ${item.title}`);
      } catch (error) {
        console.error('Upload failed:', error);
        updateQueueItem(item.id, { 
          status: 'failed', 
          error: error.response?.data?.error || 'Upload failed' 
        });
      }
    }

    setIsUploading(false);
    setCurrentIndex(0);
  };

  const pauseUpload = () => {
    setIsPaused(true);
  };

  const resumeUpload = () => {
    setIsPaused(false);
    startUpload();
  };

  const retryFailed = () => {
    setQueue(prev => prev.map(item => 
      item.status === 'failed' ? { ...item, status: 'pending', error: null } : item
    ));
  };

  const clearCompleted = () => {
    setQueue(prev => prev.filter(item => item.status !== 'success'));
  };

  const clearAll = () => {
    if (!isUploading) {
      setQueue([]);
    }
  };

  const pendingCount = queue.filter(q => q.status === 'pending').length;
  const successCount = queue.filter(q => q.status === 'success').length;
  const failedCount = queue.filter(q => q.status === 'failed').length;

  return (
    <div className="space-y-6">
      {/* Default Settings */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Default Category</label>
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Default Status</label>
          <select
            value={defaultStatus}
            onChange={(e) => setDefaultStatus(e.target.value)}
            className="input-field"
          >
            <option value="public">Public</option>
            <option value="private">Private</option>
            <option value="unlisted">Unlisted</option>
          </select>
        </div>
      </div>

      {/* Dropzone */}
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-xl p-12 text-center cursor-pointer transition-all ${
          isDragActive
            ? 'border-primary-500 bg-primary-500/10'
            : 'border-dark-100 hover:border-gray-600'
        }`}
      >
        <input {...getInputProps()} />
        <FiUploadCloud className="w-16 h-16 mx-auto text-gray-500 mb-4" />
        <p className="text-lg text-white mb-2">
          {isDragActive ? 'Drop videos here...' : 'Drag & drop videos here'}
        </p>
        <p className="text-gray-500">or click to browse files</p>
        <p className="text-gray-600 text-sm mt-4">
          Supports: MP4, MKV, AVI, MOV, WebM, FLV (Max 10GB each)
        </p>
      </div>

      {/* Queue Stats */}
      {queue.length > 0 && (
        <div className="flex flex-wrap items-center gap-4 p-4 bg-dark-100 rounded-lg">
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-gray-500"></span>
            <span className="text-gray-400">Pending: {pendingCount}</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-green-500"></span>
            <span className="text-gray-400">Completed: {successCount}</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-red-500"></span>
            <span className="text-gray-400">Failed: {failedCount}</span>
          </div>
          
          <div className="flex-1"></div>
          
          <div className="flex gap-2">
            {failedCount > 0 && (
              <button onClick={retryFailed} className="btn-secondary text-sm">
                <FiRefreshCw className="w-4 h-4" />
                Retry Failed
              </button>
            )}
            {successCount > 0 && (
              <button onClick={clearCompleted} className="btn-secondary text-sm">
                Clear Completed
              </button>
            )}
            {!isUploading && (
              <button onClick={clearAll} className="btn-secondary text-sm">
                Clear All
              </button>
            )}
          </div>
        </div>
      )}

      {/* Upload Queue */}
      {queue.length > 0 && (
        <div className="space-y-3">
          {queue.map((item) => (
            <QueueItem
              key={item.id}
              item={item}
              categories={categories}
              onUpdate={(updates) => updateQueueItem(item.id, updates)}
              onRemove={() => removeFromQueue(item.id)}
              isUploading={isUploading}
            />
          ))}
        </div>
      )}

      {/* Start/Pause Button */}
      {queue.length > 0 && pendingCount > 0 && (
        <div className="flex justify-center gap-4">
          {!isUploading ? (
            <button onClick={startUpload} className="btn-primary px-8 py-3 text-lg">
              <FiPlay className="w-5 h-5" />
              Start Upload ({pendingCount} videos)
            </button>
          ) : isPaused ? (
            <button onClick={resumeUpload} className="btn-primary px-8 py-3 text-lg">
              <FiPlay className="w-5 h-5" />
              Resume Upload
            </button>
          ) : (
            <button onClick={pauseUpload} className="btn-secondary px-8 py-3 text-lg">
              <FiPause className="w-5 h-5" />
              Pause Upload
            </button>
          )}
        </div>
      )}
    </div>
  );
};

// Queue Item Component
const QueueItem = ({ item, categories, onUpdate, onRemove, isUploading }) => {
  const statusColors = {
    pending: 'bg-gray-500',
    uploading: 'bg-blue-500',
    success: 'bg-green-500',
    failed: 'bg-red-500',
  };

  const statusIcons = {
    pending: null,
    uploading: <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />,
    success: <FiCheck className="w-4 h-4" />,
    failed: <FiAlertCircle className="w-4 h-4" />,
  };

  return (
    <div className={`bg-dark-100 rounded-lg p-4 ${item.status === 'failed' ? 'border border-red-500/50' : ''}`}>
      <div className="flex items-start gap-4">
        {/* Status Icon */}
        <div className={`w-10 h-10 rounded-lg ${statusColors[item.status]} flex items-center justify-center text-white flex-shrink-0`}>
          {statusIcons[item.status] || <FiFile className="w-5 h-5" />}
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1">
              {item.status === 'pending' ? (
                <input
                  type="text"
                  value={item.title}
                  onChange={(e) => onUpdate({ title: e.target.value })}
                  className="w-full bg-transparent text-white font-medium focus:outline-none focus:bg-dark-200 px-2 py-1 rounded -ml-2"
                  placeholder="Video title"
                />
              ) : (
                <p className="text-white font-medium truncate">{item.title}</p>
              )}
              <p className="text-gray-500 text-sm">
                {(item.size / (1024 * 1024)).toFixed(2)} MB
              </p>
            </div>

            {item.status === 'pending' && (
              <select
                value={item.category}
                onChange={(e) => onUpdate({ category: e.target.value })}
                className="px-3 py-1.5 bg-dark-200 border border-dark-100 rounded text-sm text-white"
              >
                <option value="">No Category</option>
                {categories.map(cat => (
                  <option key={cat._id} value={cat._id}>{cat.name}</option>
                ))}
              </select>
            )}

            {item.status !== 'uploading' && (
              <button
                onClick={onRemove}
                className="p-2 hover:bg-dark-200 rounded text-gray-400 hover:text-red-500"
              >
                <FiX className="w-4 h-4" />
              </button>
            )}
          </div>

          {/* Progress Bar */}
          {item.status === 'uploading' && (
            <div className="mt-3">
              <div className="flex justify-between text-sm mb-1">
                <span className="text-gray-400">Uploading...</span>
                <span className="text-white">{item.progress}%</span>
              </div>
              <div className="w-full h-2 bg-dark-200 rounded-full overflow-hidden">
                <div
                  className="h-full bg-primary-500 transition-all duration-300"
                  style={{ width: `${item.progress}%` }}
                />
              </div>
            </div>
          )}

          {/* Error Message */}
          {item.status === 'failed' && item.error && (
            <p className="text-red-500 text-sm mt-2">{item.error}</p>
          )}
        </div>
      </div>
    </div>
  );
};

// ==================== FILE CODE SECTION ====================
const FileCodeSection = ({ categories }) => {
  const [fileCodes, setFileCodes] = useState([{ file_code: '', title: '' }]);
  const [defaultCategory, setDefaultCategory] = useState('');
  const [defaultStatus, setDefaultStatus] = useState('public');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState(null);

  const addRow = () => {
    setFileCodes([...fileCodes, { file_code: '', title: '' }]);
  };

  const removeRow = (index) => {
    setFileCodes(fileCodes.filter((_, i) => i !== index));
  };

  const updateRow = (index, field, value) => {
    setFileCodes(fileCodes.map((row, i) => 
      i === index ? { ...row, [field]: value } : row
    ));
  };

  const handleSubmit = async () => {
    const validCodes = fileCodes.filter(fc => fc.file_code.trim());
    if (validCodes.length === 0) {
      toast.error('Please enter at least one file code');
      return;
    }

    setLoading(true);
    setResults(null);

    try {
      const videos = validCodes.map(fc => ({
        file_code: fc.file_code.trim(),
        title: fc.title.trim() || fc.file_code.trim(),
        category: defaultCategory || null,
        status: defaultStatus,
      }));

      const response = await adminAPI.bulkAddFileCodes(videos);
      setResults(response.data.results);
      
      // Clear successful entries
      const successCodes = response.data.results.success.map(s => s.file_code);
      setFileCodes(fileCodes.filter(fc => !successCodes.includes(fc.file_code.trim())));
      
      if (response.data.results.success.length > 0) {
        toast.success(`Added ${response.data.results.success.length} videos`);
      }
      if (response.data.results.failed.length > 0) {
        toast.error(`${response.data.results.failed.length} failed`);
      }
    } catch (error) {
      toast.error('Failed to add videos');
    } finally {
      setLoading(false);
    }
  };

  const handlePaste = (e) => {
    const pastedText = e.clipboardData.getData('text');
    const lines = pastedText.split('\n').filter(line => line.trim());
    
    if (lines.length > 1) {
      e.preventDefault();
      const newCodes = lines.map(line => {
        const parts = line.split(/[\t,]/);
        return {
          file_code: parts[0]?.trim() || '',
          title: parts[1]?.trim() || '',
        };
      });
      setFileCodes([...fileCodes.filter(fc => fc.file_code), ...newCodes]);
    }
  };

  return (
    <div className="space-y-6">
      {/* Instructions */}
      <div className="bg-dark-100 rounded-lg p-4">
        <p className="text-gray-300 text-sm">
          Enter Abyss.to file codes to add videos to your platform. You can paste multiple codes (one per line) or with titles (code, title format).
        </p>
      </div>

      {/* Default Settings */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Category</label>
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Status</label>
          <select
            value={defaultStatus}
            onChange={(e) => setDefaultStatus(e.target.value)}
            className="input-field"
          >
            <option value="public">Public</option>
            <option value="private">Private</option>
            <option value="unlisted">Unlisted</option>
          </select>
        </div>
      </div>

      {/* File Code Inputs */}
      <div className="space-y-3">
        {fileCodes.map((row, index) => (
          <div key={index} className="flex gap-3">
            <input
              type="text"
              value={row.file_code}
              onChange={(e) => updateRow(index, 'file_code', e.target.value)}
              onPaste={index === 0 ? handlePaste : undefined}
              placeholder="File code (e.g., abc123xyz)"
              className="input-field flex-1"
            />
            <input
              type="text"
              value={row.title}
              onChange={(e) => updateRow(index, 'title', e.target.value)}
              placeholder="Title (optional)"
              className="input-field flex-1"
            />
            <button
              onClick={() => removeRow(index)}
              className="p-3 hover:bg-dark-100 rounded-lg text-gray-400 hover:text-red-500"
              disabled={fileCodes.length === 1}
            >
              <FiX className="w-5 h-5" />
            </button>
          </div>
        ))}
      </div>

      {/* Add Row Button */}
      <button onClick={addRow} className="btn-secondary w-full">
        <FiPlus className="w-5 h-5" />
        Add Another
      </button>

      {/* Submit Button */}
      <button
        onClick={handleSubmit}
        disabled={loading}
        className="btn-primary w-full py-3"
      >
        {loading ? 'Adding Videos...' : `Add ${fileCodes.filter(fc => fc.file_code.trim()).length} Videos`}
      </button>

      {/* Results */}
      {results && (
        <div className="space-y-4">
          {results.success.length > 0 && (
            <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-4">
              <h4 className="text-green-500 font-medium mb-2">
                Successfully Added ({results.success.length})
              </h4>
              <div className="space-y-1 text-sm text-green-400">
                {results.success.map((s, i) => (
                  <p key={i}>{s.file_code}</p>
                ))}
              </div>
            </div>
          )}
          {results.failed.length > 0 && (
            <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4">
              <h4 className="text-red-500 font-medium mb-2">
                Failed ({results.failed.length})
              </h4>
              <div className="space-y-1 text-sm">
                {results.failed.map((f, i) => (
                  <p key={i} className="text-red-400">
                    {f.file_code}: {f.error}
                  </p>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// ==================== ABYSS FILES SECTION ====================
const AbyssFilesSection = ({ categories }) => {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedFiles, setSelectedFiles] = useState([]);
  const [importing, setImporting] = useState(false);
  const [page, setPage] = useState(1);
  const [pagination, setPagination] = useState({ total: 0 });
  const [defaultCategory, setDefaultCategory] = useState('');

  useEffect(() => {
    fetchAbyssFiles();
  }, [page]);

  const fetchAbyssFiles = async () => {
    setLoading(true);
    try {
      const response = await adminAPI.getAbyssFiles(page, 50);
      if (response.data.success) {
        setFiles(response.data.files);
        setPagination(response.data.pagination);
      }
    } catch (error) {
      toast.error('Failed to fetch files from Abyss');
    } finally {
      setLoading(false);
    }
  };

  const handleSelectFile = (fileCode) => {
    setSelectedFiles(prev =>
      prev.includes(fileCode)
        ? prev.filter(fc => fc !== fileCode)
        : [...prev, fileCode]
    );
  };

  const handleSelectAll = () => {
    const notAdded = files.filter(f => !f.alreadyAdded).map(f => f.file_code);
    if (selectedFiles.length === notAdded.length) {
      setSelectedFiles([]);
    } else {
      setSelectedFiles(notAdded);
    }
  };

  const handleImport = async () => {
    if (selectedFiles.length === 0) return;

    setImporting(true);
    try {
      const videos = selectedFiles.map(file_code => {
        const file = files.find(f => f.file_code === file_code);
        return {
          file_code,
          title: file?.title || file_code,
          category: defaultCategory || null,
        };
      });

      const response = await adminAPI.bulkAddFileCodes(videos);
      
      // Update files list
      const successCodes = response.data.results.success.map(s => s.file_code);
      setFiles(files.map(f => 
        successCodes.includes(f.file_code) ? { ...f, alreadyAdded: true } : f
      ));
      setSelectedFiles([]);
      
      toast.success(`Imported ${response.data.results.success.length} videos`);
    } catch (error) {
      toast.error('Failed to import videos');
    } finally {
      setImporting(false);
    }
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  return (
    <div className="space-y-6">
      {/* Category Selection */}
      <div className="flex items-center justify-between gap-4 flex-wrap">
        <div className="flex items-center gap-4">
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field w-48"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
          
          <button onClick={handleSelectAll} className="btn-secondary">
            Select All Available
          </button>
        </div>

        {selectedFiles.length > 0 && (
          <button
            onClick={handleImport}
            disabled={importing}
            className="btn-primary"
          >
            {importing ? 'Importing...' : `Import ${selectedFiles.length} Videos`}
          </button>
        )}
      </div>

      {/* Files Grid */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {files.map((file) => (
          <div
            key={file.file_code}
            onClick={() => !file.alreadyAdded && handleSelectFile(file.file_code)}
            className={`relative rounded-lg overflow-hidden cursor-pointer transition-all ${
              file.alreadyAdded 
                ? 'opacity-50 cursor-not-allowed' 
                : selectedFiles.includes(file.file_code)
                  ? 'ring-2 ring-primary-500'
                  : 'hover:ring-2 hover:ring-gray-500'
            }`}
          >
            <div className="aspect-video bg-dark-100">
              <img
                src={`https://abyss.to/thumb/${file.file_code}.jpg`}
                alt={file.title}
                className="w-full h-full object-cover"
                onError={(e) => {
  e.target.src =
    "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIwIiBoZWlnaHQ9IjE4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWUxZTFlIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNiIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIFRodW1ibmFpbDwvdGV4dD48L3N2Zz4=";
}}

              />
            </div>
            
            {/* Selection Overlay */}
            {selectedFiles.includes(file.file_code) && (
              <div className="absolute inset-0 bg-primary-500/30 flex items-center justify-center">
                <div className="w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center">
                  <FiCheck className="w-5 h-5 text-white" />
                </div>
              </div>
            )}

            {/* Already Added Badge */}
            {file.alreadyAdded && (
              <div className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">
                Added
              </div>
            )}

            <div className="p-2">
              <p className="text-white text-sm truncate">{file.title || file.file_code}</p>
              <p className="text-gray-500 text-xs">{file.file_code}</p>
            </div>
          </div>
        ))}
      </div>

      {/* Pagination */}
      <div className="flex justify-center gap-2">
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
          className="btn-secondary"
        >
          Previous
        </button>
        <span className="px-4 py-2 text-gray-400">
          Page {page}
        </span>
        <button
          onClick={() => setPage(p => p + 1)}
          disabled={files.length < 50}
          className="btn-secondary"
        >
          Next
        </button>
      </div>
    </div>
  );
};

export default UploadPage;

backend/routes/uploadRoutes.js — to see how upload works


const express = require("express");
const router = express.Router();
const multer = require("multer");
const path = require("path");
const fs = require("fs");
const os = require("os");

const abyssService = require("../abyssService");
const Video = require("../models/Video");
const DuplicateDetector = require("../utils/duplicateDetector");
const { extractThumbnail, getVideoMetadata, cleanupThumbnail } = require("../utils/videoProcessor");
const { uploadImage, deleteImage } = require("../config/cloudinary");

// ============================================
// DISK STORAGE for large files
// ============================================
const uploadDir = path.join(os.tmpdir(), "xmaster-uploads");
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

const storage = multer.diskStorage({
  destination: (req, file, cb) => cb(null, uploadDir),
  filename: (req, file, cb) => {
    const uniqueName = `${Date.now()}-${Math.round(Math.random() * 1e9)}${path.extname(file.originalname)}`;
    cb(null, uniqueName);
  },
});

const fileFilter = (req, file, cb) => {
  const allowed = [
    "video/mp4", "video/mpeg", "video/quicktime",
    "video/x-msvideo", "video/x-matroska", "video/webm",
    "video/x-flv", "video/3gpp", "application/octet-stream",
  ];

  if (allowed.includes(file.mimetype) || file.originalname.match(/\.(mp4|mkv|avi|mov|webm|flv|3gp)$/i)) {
    cb(null, true);
  } else {
    cb(new Error("Invalid file type. Only video files are allowed."), false);
  }
};

const upload = multer({
  storage,
  fileFilter,
  limits: { fileSize: 10 * 1024 * 1024 * 1024 },
});

// Helper: clean up file
const cleanupFile = (filePath) => {
  try {
    if (filePath && fs.existsSync(filePath)) {
      fs.unlinkSync(filePath);
      console.log("🧹 Cleaned up:", path.basename(filePath));
    }
  } catch (err) {
    console.error("⚠️ Cleanup error:", err.message);
  }
};

/**
 * POST /api/upload/single
 */
router.post("/single", upload.single("video"), async (req, res) => {
  let videoTempPath = null;
  let thumbnailTempPath = null;

  try {
    console.log("═══════════════════════════════════════");
    console.log("📤 Upload request received");
    console.log("═══════════════════════════════════════");

    if (!req.file) {
      return res.status(400).json({ success: false, error: "No video file uploaded" });
    }

    videoTempPath = req.file.path;
    const { title, description, category, status } = req.body;

    if (!title || title.trim() === "") {
      cleanupFile(videoTempPath);
      return res.status(400).json({ success: false, error: "Title is required" });
    }

    const safeCategory = category?.trim() || "General";
    const safeStatus = ["public", "private", "unlisted"].includes(status) ? status : "public";

    console.log("📊 Upload details:", {
      fileName: req.file.originalname,
      fileSize: `${(req.file.size / 1024 / 1024).toFixed(2)} MB`,
      title: title.trim(),
      category: safeCategory,
    });

    // STEP 1: Extract video metadata (duration)
    console.log("⏱️ Extracting video metadata...");
    const metadata = await getVideoMetadata(videoTempPath);
    const durationFormatted = metadata.durationFormatted || "00:00";
    console.log("✅ Duration:", durationFormatted);

    // STEP 2: Extract thumbnail from video
    console.log("📸 Extracting thumbnail...");
    thumbnailTempPath = await extractThumbnail(videoTempPath);

    let cloudinaryUrl = "";
    let cloudinaryPublicId = "";

    if (thumbnailTempPath) {
      // STEP 3: Upload thumbnail to Cloudinary
      console.log("☁️ Uploading thumbnail to Cloudinary...");
      const cloudResult = await uploadImage(thumbnailTempPath, "xmaster-thumbnails");
      cloudinaryUrl = cloudResult.url;
      cloudinaryPublicId = cloudResult.publicId;
      console.log("✅ Cloudinary URL:", cloudinaryUrl);

      cleanupThumbnail(thumbnailTempPath);
      thumbnailTempPath = null;
    } else {
      console.log("⚠️ Thumbnail extraction failed, will use placeholder");
    }

    // STEP 4: Upload video to Abyss.to
    console.log("📤 Uploading video to Abyss.to...");
    const abyssData = await abyssService.uploadVideoFromPath(
      videoTempPath,
      req.file.originalname
    );

    console.log("✅ Abyss upload complete:", {
      slug: abyssData.slug,
      embedUrl: abyssData.embedUrl,
    });

    cleanupFile(videoTempPath);
    videoTempPath = null;

    const finalFileCode = abyssData.filecode || abyssData.slug;
    const finalEmbedUrl = abyssData.embedUrl || `https://short.icu/${finalFileCode}`;

    if (!finalFileCode) {
      throw new Error("Abyss upload succeeded but filecode/slug is missing");
    }

    const finalThumbnail = cloudinaryUrl || `https://abyss.to/splash/${finalFileCode}.jpg`;

    // Check for exact file_code duplicate
    const existing = await Video.findOne({ file_code: finalFileCode });
    if (existing) {
      if (cloudinaryPublicId) {
        await deleteImage(cloudinaryPublicId);
      }
      return res.status(409).json({
        success: false,
        error: "This video has already been uploaded",
        video: existing,
      });
    }

    // --- DUPLICATE DETECTION ---
    const durationParts = durationFormatted.split(":").map(Number);
    let durationSeconds = 0;
    if (durationParts.length === 3) {
      durationSeconds = durationParts[0] * 3600 + durationParts[1] * 60 + durationParts[2];
    } else if (durationParts.length === 2) {
      durationSeconds = durationParts[0] * 60 + durationParts[1];
    }

    const dupCheck = await DuplicateDetector.checkDuplicate({
      title: title.trim(),
      duration_seconds: durationSeconds,
      file_code: finalFileCode,
    });

    const finalStatus = dupCheck.isDuplicate ? "private" : safeStatus;

    if (dupCheck.isDuplicate) {
      console.log(`🔄 Duplicate detected: "${title.trim()}" [${dupCheck.reasons.join(", ")}]`);
    }
    // --- END DUPLICATE DETECTION ---

    // STEP 5: Save to MongoDB
    const newVideo = new Video({
      title: title.trim(),
      description: description?.trim() || "",
      file_code: finalFileCode,
      embed_code: finalEmbedUrl,
      thumbnail: finalThumbnail,
      cloudinary_public_id: cloudinaryPublicId || "",
      duration: durationFormatted,
      views: 0,
      category: safeCategory,
      status: finalStatus,
      isDuplicate: dupCheck.isDuplicate,
      duplicateOf: dupCheck.duplicateOf,
      duplicateReasons: dupCheck.reasons,
      uploadDate: new Date(),
    });

    await newVideo.save();

    console.log("✅ Video saved to DB:", {
      id: newVideo._id,
      file_code: newVideo.file_code,
      title: newVideo.title,
      thumbnail: newVideo.thumbnail,
      duration: newVideo.duration,
      embed: newVideo.embed_code,
      isDuplicate: newVideo.isDuplicate,
      duplicateReasons: newVideo.duplicateReasons,
    });
    console.log("═══════════════════════════════════════");

    return res.status(201).json({
      success: true,
      message: dupCheck.isDuplicate
        ? "Video uploaded but marked as duplicate (set to private)"
        : "Video uploaded successfully",
      video: newVideo,
      duplicate: dupCheck.isDuplicate ? {
        reasons: dupCheck.reasons,
        matches: dupCheck.matches,
      } : null,
    });
  } catch (error) {
    if (videoTempPath) cleanupFile(videoTempPath);
    if (thumbnailTempPath) cleanupThumbnail(thumbnailTempPath);

    console.error("══��════════════════════════════════════");
    console.error("❌ Upload error:", error.message);
    console.error("❌ Stack:", error.stack);
    console.error("═══════════════════════════════════════");

    return res.status(500).json({
      success: false,
      error: "Upload failed",
      message: error.message,
    });
  }
});

/**
 * POST /api/upload/file-code
 */
router.post("/file-code", async (req, res) => {
  try {
    const { file_code, title, category, status, tags } = req.body;

    if (!file_code?.trim()) {
      return res.status(400).json({ success: false, error: "File code is required" });
    }

    const cleanCode = file_code.trim();

    // Check exact duplicate
    const existing = await Video.findOne({ file_code: cleanCode });
    if (existing) {
      return res.status(409).json({
        success: false,
        error: "Video with this file code already exists",
        video: existing,
      });
    }

    const videoTitle = title?.trim() || cleanCode;
    const embedUrl = `https://short.icu/${cleanCode}`;
    const thumbnail = `https://abyss.to/splash/${cleanCode}.jpg`;

    // --- DUPLICATE DETECTION ---
    const dupCheck = await DuplicateDetector.checkDuplicate({
      title: videoTitle,
      duration_seconds: 0,
      file_code: cleanCode,
    });

    const finalStatus = dupCheck.isDuplicate ? "private" : (status || "public");

    if (dupCheck.isDuplicate) {
      console.log(`🔄 Duplicate detected (file-code): "${videoTitle}" [${dupCheck.reasons.join(", ")}]`);
    }
    // --- END DUPLICATE DETECTION ---

    const newVideo = new Video({
      title: videoTitle,
      file_code: cleanCode,
      embed_code: embedUrl,
      thumbnail: thumbnail,
      duration: "00:00",
      views: 0,
      category: category?.trim() || "General",
      status: finalStatus,
      tags: tags || [],
      isDuplicate: dupCheck.isDuplicate,
      duplicateOf: dupCheck.duplicateOf,
      duplicateReasons: dupCheck.reasons,
      uploadDate: new Date(),
    });

    await newVideo.save();
    console.log("✅ Video added by file code:", cleanCode, dupCheck.isDuplicate ? "(DUPLICATE)" : "");

    return res.status(201).json({
      success: true,
      message: dupCheck.isDuplicate
        ? "Video added but marked as duplicate (set to private)"
        : "Video added successfully",
      video: newVideo,
      duplicate: dupCheck.isDuplicate ? {
        reasons: dupCheck.reasons,
        matches: dupCheck.matches,
      } : null,
    });
  } catch (error) {
    console.error("❌ File code error:", error.message);
    return res.status(500).json({
      success: false,
      error: "Failed to add video",
      message: error.message,
    });
  }
});

/**
 * POST /api/upload/bulk-file-codes
 */
router.post("/bulk-file-codes", async (req, res) => {
  try {
    const { videos } = req.body;

    if (!videos || !Array.isArray(videos) || videos.length === 0) {
      return res.status(400).json({ success: false, error: "No videos provided" });
    }

    const results = { success: [], failed: [], duplicates: [] };

    for (const videoData of videos) {
      try {
        const cleanCode = videoData.file_code?.trim();
        if (!cleanCode) {
          results.failed.push({ file_code: videoData.file_code, error: "Empty file code" });
          continue;
        }

        const existing = await Video.findOne({ file_code: cleanCode });
        if (existing) {
          results.failed.push({ file_code: cleanCode, error: "Already exists" });
          continue;
        }

        const videoTitle = videoData.title?.trim() || cleanCode;

        // --- DUPLICATE DETECTION ---
        const dupCheck = await DuplicateDetector.checkDuplicate({
          title: videoTitle,
          duration_seconds: 0,
          file_code: cleanCode,
        });

        const finalStatus = dupCheck.isDuplicate ? "private" : (videoData.status || "public");
        // --- END DUPLICATE DETECTION ---

        const newVideo = new Video({
          title: videoTitle,
          file_code: cleanCode,
          embed_code: `https://short.icu/${cleanCode}`,
          thumbnail: `https://abyss.to/splash/${cleanCode}.jpg`,
          duration: "00:00",
          views: 0,
          category: videoData.category?.trim() || "General",
          status: finalStatus,
          tags: videoData.tags || [],
          isDuplicate: dupCheck.isDuplicate,
          duplicateOf: dupCheck.duplicateOf,
          duplicateReasons: dupCheck.reasons,
          uploadDate: new Date(),
        });

        await newVideo.save();

        if (dupCheck.isDuplicate) {
          results.duplicates.push({
            file_code: cleanCode,
            id: newVideo._id,
            title: newVideo.title,
            reasons: dupCheck.reasons,
          });
          console.log(`🔄 Bulk duplicate: "${videoTitle}" [${dupCheck.reasons.join(", ")}]`);
        } else {
          results.success.push({ file_code: cleanCode, id: newVideo._id, title: newVideo.title });
        }
      } catch (err) {
        results.failed.push({ file_code: videoData.file_code, error: err.message });
      }
    }

    console.log(`✅ Bulk: ${results.success.length} success, ${results.duplicates.length} duplicates, ${results.failed.length} failed`);

    return res.status(200).json({ success: true, results });
  } catch (error) {
    console.error("❌ Bulk error:", error.message);
    return res.status(500).json({ success: false, error: "Bulk add failed", message: error.message });
  }
});

/**
 * POST /api/upload/thumbnail
 */
router.post("/thumbnail", upload.single("thumbnail"), async (req, res) => {
  let tempPath = null;

  try {
    if (!req.file) {
      return res.status(400).json({ success: false, error: "No image file uploaded" });
    }

    tempPath = req.file.path;

    const cloudResult = await uploadImage(tempPath, "xmaster-thumbnails");

    cleanupFile(tempPath);
    tempPath = null;

    return res.status(200).json({
      success: true,
      url: cloudResult.url,
      publicId: cloudResult.publicId,
    });
  } catch (error) {
    if (tempPath) cleanupFile(tempPath);
    console.error("❌ Thumbnail upload error:", error.message);
    return res.status(500).json({ success: false, error: "Thumbnail upload failed" });
  }
});

/**
 * GET /api/upload/abyss-files
 */
router.get("/abyss-files", async (req, res) => {
  try {
    const page = parseInt(req.query.page) || 1;
    const limit = parseInt(req.query.limit) || 50;

    const abyssData = await abyssService.getFileList(page, limit);

    const existingVideos = await Video.find({}, { file_code: 1 }).lean();
    const existingCodes = new Set(existingVideos.map((v) => v.file_code));

    const files = (abyssData?.result?.files || abyssData?.files || []).map((file) => ({
      file_code: file.file_code || file.filecode || file.slug,
      title: file.title || file.name || file.file_code,
      thumbnail: `https://abyss.to/splash/${file.file_code || file.slug}.jpg`,
      duration: file.length || file.duration || 0,
      views: file.views || 0,
      alreadyAdded: existingCodes.has(file.file_code || file.filecode || file.slug),
    }));

    return res.status(200).json({
      success: true,
      files,
      pagination: { page, total: abyssData?.result?.total || files.length },
    });
  } catch (error) {
    console.error("❌ Abyss files error:", error.message);
    return res.status(500).json({ success: false, error: "Failed to fetch files" });
  }
});

/**
 * GET /api/upload/account-info
 */
router.get("/account-info", async (req, res) => {
  try {
    const info = await abyssService.getAccountInfo();
    return res.status(200).json({ success: true, account: info });
  } catch (error) {
    return res.status(500).json({ success: false, error: "Failed to fetch account info" });
  }
});

module.exports = router;
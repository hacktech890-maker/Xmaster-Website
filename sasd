Backend:
backend/server.js

const express = require("express");
const cors = require("cors");
const mongoose = require("mongoose");
const rateLimit = require("express-rate-limit");
require("dotenv").config();

const app = express();

// Trust proxy for deployment platforms like Render
app.set("trust proxy", 1);

// ============================================
// CORS CONFIGURATION - VERY IMPORTANT!
// ============================================
const allowedOrigins = [
  "https://xmaster-videoss.netlify.app",
  "https://xmaster-cj1.pages.dev", // âœ… Cloudflare Pages Domain (change if different)
  "http://localhost:3000",
  "http://localhost:3001",
];

// Add any origins from environment variable
if (process.env.FRONTEND_URL) {
  const envOrigins = process.env.FRONTEND_URL.split(",").map((url) => url.trim());

  envOrigins.forEach((origin) => {
    if (!allowedOrigins.includes(origin)) {
      allowedOrigins.push(origin);
    }
  });
}

console.log("âœ… Allowed Origins:", allowedOrigins);

// ============================================
// CORS Middleware
// ============================================
app.use(
  cors({
    origin: function (origin, callback) {
      // Allow requests with no origin (like mobile apps, curl, Postman)
      if (!origin) {
        return callback(null, true);
      }

      // Check if origin is allowed
      if (allowedOrigins.includes(origin)) {
        return callback(null, true);
      }

      // Block unauthorized origins
      console.log("âš ï¸ CORS blocked origin:", origin);
      return callback(new Error("Not allowed by CORS"));
    },
    credentials: true,
    methods: ["GET", "POST", "PUT", "DELETE", "PATCH", "OPTIONS"],
    allowedHeaders: [
      "Content-Type",
      "Authorization",
      "X-Requested-With",
      "Accept",
      "Origin",
    ],
    exposedHeaders: ["Content-Range", "X-Content-Range"],
    maxAge: 86400, // 24 hours
  })
);

// Handle preflight requests for all routes
app.options(
  "*",
  cors({
    origin: allowedOrigins,
    credentials: true,
  })
);

// ============================================
// MIDDLEWARE
// ============================================
app.use(express.json({ limit: "50mb" }));
app.use(express.urlencoded({ extended: true, limit: "50mb" }));

// ============================================
// RATE LIMITING
// ============================================
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 1000,
  message: { error: "Too many requests, please try again later." },
  standardHeaders: true,
  legacyHeaders: false,
});
app.use("/api/", limiter);

// ============================================
// MONGODB CONNECTION
// ============================================
mongoose
  .connect(process.env.MONGODB_URI)
  .then(() => console.log("âœ… MongoDB Connected Successfully"))
  .catch((err) => console.error("âŒ MongoDB Connection Error:", err));

// ============================================
// IMPORT ROUTES
// ============================================
const adminRoutes = require("./routes/adminRoutes");
const videoRoutes = require("./routes/videoRoutes");
const uploadRoutes = require("./routes/uploadRoutes");
const categoryRoutes = require("./routes/categoryRoutes");
const adRoutes = require("./routes/adRoutes");
const searchRoutes = require("./routes/searchRoutes");
const publicRoutes = require("./routes/publicRoutes");

// ============================================
// USE ROUTES
// ============================================
app.use("/api/admin", adminRoutes);
app.use("/api/videos", videoRoutes);
app.use("/api/upload", uploadRoutes);
app.use("/api/categories", categoryRoutes);
app.use("/api/ads", adRoutes);
app.use("/api/search", searchRoutes);
app.use("/api/public", publicRoutes);

// ============================================
// HEALTH CHECK ROUTES
// ============================================
app.get("/", (req, res) => {
  res.json({
    message: "XMASTER API is running!",
    status: "healthy",
    timestamp: new Date().toISOString(),
    cors: "enabled",
    allowedOrigins: allowedOrigins,
  });
});

app.get("/api/health", (req, res) => {
  res.json({
    status: "ok",
    mongodb: mongoose.connection.readyState === 1 ? "connected" : "disconnected",
    cors: "enabled",
  });
});

// ============================================
// 404 HANDLER
// ============================================
app.use((req, res) => {
  res.status(404).json({ error: "Route not found", path: req.path });
});

// ============================================
// ERROR HANDLER
// ============================================
app.use((err, req, res, next) => {
  console.error("âŒ Error:", err);

  res.status(err.status || 500).json({
    error: err.message || "Internal Server Error",
  });
});

// ============================================
// START SERVER
// ============================================
const PORT = process.env.PORT || 5000;

app.listen(PORT, () => {
  console.log(`ðŸš€ Server running on port ${PORT}`);
  console.log(`ðŸ“ Environment: ${process.env.NODE_ENV || "development"}`);
  console.log(`ðŸŒ CORS enabled for: ${allowedOrigins.join(", ")}`);
});


backend/routes/uploadRoutes.js

const express = require("express");
const router = express.Router();
const multer = require("multer");

const abyssService = require("../abyssServices");
const Video = require("../models/Video");

// Multer memory storage
const upload = multer({
  storage: multer.memoryStorage(),
  limits: { fileSize: 10 * 1024 * 1024 * 1024 }, // 10GB
});

/**
 * POST /api/upload/single
 * Upload video to Abyss.to and save to MongoDB
 */
router.post("/single", upload.single("video"), async (req, res) => {
  try {
    console.log("ðŸ“¤ Upload request received");

    if (!req.file) {
      return res.status(400).json({
        success: false,
        error: "No video file uploaded",
      });
    }

    const { title, description, category } = req.body;

    if (!title || title.trim() === "") {
      return res.status(400).json({
        success: false,
        error: "Title is required",
      });
    }

    const safeCategory =
      category && category.trim() ? category.trim() : "General";

    console.log("ðŸ“Š Upload details:", {
      fileName: req.file.originalname,
      fileSize: `${(req.file.size / 1024 / 1024).toFixed(2)}MB`,
      title: title.trim(),
      category: safeCategory,
    });

    // Upload to Abyss
    const abyssData = await abyssService.uploadVideo(
      req.file.buffer,
      req.file.originalname
    );

    const finalFileCode = abyssData.filecode;
    const finalEmbedUrl = abyssData.embedUrl || "";
    const finalThumbnail =
      abyssData.thumbnail ||
      (finalFileCode ? `https://abyss.to/splash/${finalFileCode}.jpg` : "");

    if (!finalFileCode) {
      throw new Error("Abyss upload succeeded but filecode missing");
    }

    // Fetch duration from Abyss API
    let finalDuration = "00:00";

    try {
      const fileInfo = await abyssService.getFileInfo(finalFileCode);

      const durationSeconds =
        fileInfo?.result?.length ||
        fileInfo?.result?.duration ||
        fileInfo?.length ||
        fileInfo?.duration ||
        0;

      finalDuration = abyssService.secondsToDuration(durationSeconds);
    } catch (infoErr) {
      console.log("âš ï¸ Could not fetch Abyss file info:", infoErr.message);
    }

    // Save to DB
    const newVideo = new Video({
      title: title.trim(),
      description: description?.trim() || "",
      file_code: finalFileCode,
      embed_code: finalEmbedUrl,
      thumbnail: finalThumbnail,
      duration: finalDuration,
      views: 0,
      category: safeCategory,
      uploadDate: new Date(),
    });

    await newVideo.save();

    console.log("âœ… Video saved:", newVideo._id);

    return res.status(201).json({
      success: true,
      message: "Video uploaded successfully",
      video: newVideo,
    });
  } catch (error) {
    console.error("âŒ Upload error:", error);

    return res.status(500).json({
      success: false,
      error: "Upload failed",
      message: error.message,
    });
  }
});

module.exports = router;


backend/models/Video.js

const mongoose = require("mongoose");

const videoSchema = new mongoose.Schema(
  {
    file_code: {
      type: String,
      required: true,
      unique: true,
      index: true,
    },

    embed_code: {
      type: String,
      default: "",
    },

    title: {
      type: String,
      required: true,
      trim: true,
      maxlength: 200,
    },

    slug: {
      type: String,
      unique: true,
      sparse: true,
    },

    description: {
      type: String,
      default: "",
      maxlength: 5000,
    },

    thumbnail: {
      type: String,
      required: true,
    },

    duration: {
      type: String,
      default: "00:00",
    },

    // FIXED: category should be string
    category: {
      type: String,
      default: "General",
      index: true,
    },

    tags: [
      {
        type: String,
        lowercase: true,
        trim: true,
      },
    ],

    views: {
      type: Number,
      default: 0,
      index: true,
    },

    likes: {
      type: Number,
      default: 0,
    },

    dislikes: {
      type: Number,
      default: 0,
    },

    status: {
      type: String,
      enum: ["public", "private", "unlisted", "processing"],
      default: "public",
      index: true,
    },

    featured: {
      type: Boolean,
      default: false,
      index: true,
    },

    uploadDate: {
      type: Date,
      default: Date.now,
      index: true,
    },
  },
  {
    timestamps: true,
  }
);

// Create slug + embed_code before saving
videoSchema.pre("save", function (next) {
  if (this.title && !this.slug) {
    this.slug =
      this.title
        .toLowerCase()
        .replace(/[^a-z0-9]+/g, "-")
        .replace(/^-|-$/g, "") +
      "-" +
      this.file_code.substring(0, 8);
  }

  // FIXED: use short.icu format
  if (this.slug && !this.embed_code) {
    this.embed_code = `https://short.icu/${this.slug}`;
  }

  next();
});

videoSchema.index({ title: "text", tags: "text", description: "text" });

module.exports = mongoose.model("Video", videoSchema);


backend/middleware/upload.js

const multer = require('multer');
const path = require('path');
const fs = require('fs');

// Create uploads directory if it doesn't exist
const uploadDir = '/tmp/uploads';
if (!fs.existsSync(uploadDir)) {
  fs.mkdirSync(uploadDir, { recursive: true });
}

// Storage configuration
const storage = multer.diskStorage({
  destination: function (req, file, cb) {
    cb(null, uploadDir);
  },
  filename: function (req, file, cb) {
    const uniqueSuffix = Date.now() + '-' + Math.round(Math.random() * 1E9);
    cb(null, uniqueSuffix + path.extname(file.originalname));
  }
});

// File filter for videos
const videoFilter = (req, file, cb) => {
  const allowedTypes = [
    'video/mp4',
    'video/mpeg',
    'video/quicktime',
    'video/x-msvideo',
    'video/x-matroska',
    'video/webm',
    'video/x-flv',
    'video/3gpp',
    'application/octet-stream'
  ];

  if (allowedTypes.includes(file.mimetype) || file.originalname.match(/\.(mp4|mkv|avi|mov|webm|flv|3gp)$/i)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only video files are allowed.'), false);
  }
};

// File filter for images
const imageFilter = (req, file, cb) => {
  const allowedTypes = ['image/jpeg', 'image/png', 'image/gif', 'image/webp'];

  if (allowedTypes.includes(file.mimetype)) {
    cb(null, true);
  } else {
    cb(new Error('Invalid file type. Only image files are allowed.'), false);
  }
};

// Video upload configuration
const videoUpload = multer({
  storage: storage,
  fileFilter: videoFilter,
  limits: {
    fileSize: 10 * 1024 * 1024 * 1024, // 10GB max
  }
});

// Image upload configuration
const imageUpload = multer({
  storage: storage,
  fileFilter: imageFilter,
  limits: {
    fileSize: 10 * 1024 * 1024, // 10MB max
  }
});

// Clean up uploaded file
const cleanupFile = (filePath) => {
  if (filePath && fs.existsSync(filePath)) {
    fs.unlink(filePath, (err) => {
      if (err) console.error('Error deleting file:', err);
    });
  }
};

module.exports = {
  videoUpload,
  imageUpload,
  cleanupFile,
  uploadDir
};

backend/config/abyss.js

const axios = require("axios");
const FormData = require("form-data");

const ABYSS_API_KEY = process.env.ABYSS_API_KEY;

const ABYSS_UPLOAD_BASE = "https://up.abyss.to";
const ABYSS_API_BASE = "https://api.abyss.to";

class AbyssService {
  constructor() {
    if (!ABYSS_API_KEY) {
      console.warn("âš ï¸ ABYSS_API_KEY is missing in environment variables!");
    }

    this.apiKey = ABYSS_API_KEY;
    this.uploadBaseUrl = ABYSS_UPLOAD_BASE;
    this.apiBaseUrl = ABYSS_API_BASE;
  }

  async uploadVideo(fileBuffer, fileName) {
    try {
      if (!this.apiKey) {
        throw new Error("ABYSS_API_KEY is missing");
      }

      const formData = new FormData();
      formData.append("file", fileBuffer, fileName);

      const uploadUrl = `${this.uploadBaseUrl}/${this.apiKey}`;

      const response = await axios.post(uploadUrl, formData, {
        headers: {
          ...formData.getHeaders(),
        },
        maxBodyLength: Infinity,
        maxContentLength: Infinity,
      });

      if (!response.data || !response.data.slug) {
        throw new Error("Invalid Abyss.to upload response");
      }

      const slug = response.data.slug;

      // Sometimes abyss returns filecode/id, sometimes not
      const filecode = response.data.id || response.data.filecode || slug;

      const embedUrl = `https://short.icu/${slug}`;
      const downloadUrl = `https://abyss.to/${filecode}`;

      // âœ… Correct working thumbnail URL
      const thumbnail = `https://img.abyss.to/preview/${slug}.jpg`;

      return {
        filecode,
        slug,
        embedUrl,
        downloadUrl,
        thumbnail,
        rawResponse: response.data,
      };
    } catch (error) {
      console.error("Abyss upload error:", error.response?.data || error.message);
      throw new Error(`Abyss.to upload failed: ${error.message}`);
    }
  }

  async getFileInfo(filecode) {
    try {
      const response = await axios.get(`${this.apiBaseUrl}/file/info`, {
        params: {
          api_key: this.apiKey,
          file_code: filecode,
        },
      });

      return response.data;
    } catch (error) {
      console.error("Abyss file info error:", error.message);
      throw error;
    }
  }

  async getAccountInfo() {
    try {
      const response = await axios.get(`${this.apiBaseUrl}/account/info`, {
        params: {
          api_key: this.apiKey,
        },
      });

      return response.data;
    } catch (error) {
      console.error("Abyss account info error:", error.message);
      throw error;
    }
  }
}

module.exports = new AbyssService();


backend/abyssService.js

const axios = require("axios");
const FormData = require("form-data");

class AbyssService {
  constructor() {
    this.apiKey = process.env.ABYSS_API_KEY;
    this.uploadBaseUrl = "https://up.abyss.to";

    if (!this.apiKey) {
      console.error("âŒ ABYSS_API_KEY is not set in environment variables");
    }
  }

  async uploadVideo(fileBuffer, fileName) {
    if (!this.apiKey) {
      throw new Error("ABYSS_API_KEY missing in env");
    }

    console.log("ðŸ“¤ Uploading video to Abyss.to:", fileName);

    const formData = new FormData();
    formData.append("file", fileBuffer, fileName);

    const uploadUrl = `${this.uploadBaseUrl}/${this.apiKey}`;

    const response = await axios.post(uploadUrl, formData, {
      headers: { ...formData.getHeaders() },
      maxContentLength: Infinity,
      maxBodyLength: Infinity,
      timeout: 600000,
    });

    console.log("âœ… Abyss upload response:", response.data);

    const slug = response.data?.slug;
    const embedUrl = response.data?.urlIframe || (slug ? `https://short.icu/${slug}` : "");

    if (!slug) {
      throw new Error("Abyss upload failed: slug missing");
    }

    // Abyss preview image uses slug
    const thumbnail = `https://img.abyss.to/preview/${slug}.jpg`;

    return {
      filecode: slug, // store slug in DB as file_code
      slug,
      embedUrl,
      thumbnail,
    };
  }

  // Not available anymore (remove usage)
  async getFileInfo() {
    return null;
  }

  secondsToDuration() {
    return "00:00";
  }
}

module.exports = new AbyssService();


backend/package.json

{
  "name": "xmaster-backend",
  "version": "1.0.0",
  "description": "Backend for XMASTER video platform",
  "main": "server.js",
  "scripts": {
    "start": "node server.js",
    "dev": "nodemon server.js"
  },
  "dependencies": {
    "axios": "^1.6.2",
    "bcryptjs": "^2.4.3",
    "cloudinary": "^1.41.0",
    "cors": "^2.8.5",
    "dotenv": "^16.3.1",
    "express": "^4.18.2",
    "express-rate-limit": "^7.1.5",
    "form-data": "^4.0.0",
    "jsonwebtoken": "^9.0.2",
    "mongoose": "^8.0.3",
    "multer": "^1.4.5-lts.1",
    "sharp": "^0.34.5",
    "slugify": "^1.6.6"
  },
  "engines": {
    "node": "18.x"
  }
}


Frontend:
frontend/src/pages/admin/UploadPage.jsx

import React, { useState, useEffect, useCallback } from 'react';
import { useDropzone } from 'react-dropzone';
import { 
  FiUploadCloud, FiFile, FiX, FiCheck, FiAlertCircle, 
  FiRefreshCw, FiPlay, FiPause, FiPlus, FiLink 
} from 'react-icons/fi';
import toast from 'react-hot-toast';
import { adminAPI, publicAPI } from '../../services/api';
import AdminLayout from '../../components/admin/AdminLayout';
import LoadingSpinner from '../../components/common/LoadingSpinner';

const UploadPage = () => {
  const [activeTab, setActiveTab] = useState('upload'); // upload, file-code, abyss-files
  const [categories, setCategories] = useState([]);
  
  // Fetch categories
  useEffect(() => {
    publicAPI.getCategories()
      .then(res => {
        if (res.data.success) {
          setCategories(res.data.categories);
        }
      })
      .catch(console.error);
  }, []);

  const tabs = [
    { id: 'upload', label: 'Upload Videos', icon: FiUploadCloud },
    { id: 'file-code', label: 'Add by File Code', icon: FiLink },
    { id: 'abyss-files', label: 'Import from Abyss', icon: FiFile },
  ];

  return (
    <AdminLayout title="Upload Videos">
      {/* Tabs */}
      <div className="bg-dark-200 rounded-xl border border-dark-100 mb-6">
        <div className="flex border-b border-dark-100">
          {tabs.map((tab) => (
            <button
              key={tab.id}
              onClick={() => setActiveTab(tab.id)}
              className={`flex items-center gap-2 px-6 py-4 font-medium transition-colors ${
                activeTab === tab.id
                  ? 'text-primary-500 border-b-2 border-primary-500'
                  : 'text-gray-400 hover:text-white'
              }`}
            >
              <tab.icon className="w-5 h-5" />
              {tab.label}
            </button>
          ))}
        </div>

        <div className="p-6">
          {activeTab === 'upload' && <BulkUploadSection categories={categories} />}
          {activeTab === 'file-code' && <FileCodeSection categories={categories} />}
          {activeTab === 'abyss-files' && <AbyssFilesSection categories={categories} />}
        </div>
      </div>
    </AdminLayout>
  );
};

// ==================== BULK UPLOAD SECTION ====================
const BulkUploadSection = ({ categories }) => {
  const [queue, setQueue] = useState([]);
  const [isUploading, setIsUploading] = useState(false);
  const [isPaused, setIsPaused] = useState(false);
  const [currentIndex, setCurrentIndex] = useState(0);
  const [defaultCategory, setDefaultCategory] = useState('');
  const [defaultStatus, setDefaultStatus] = useState('public');

  const onDrop = useCallback((acceptedFiles) => {
    const newFiles = acceptedFiles.map(file => ({
      id: Math.random().toString(36).substr(2, 9),
      file,
      name: file.name,
      title: file.name.replace(/\.[^/.]+$/, '').replace(/[-_]/g, ' '),
      size: file.size,
      status: 'pending', // pending, uploading, success, failed
      progress: 0,
      error: null,
      category: defaultCategory,
      videoStatus: defaultStatus,
    }));
    setQueue(prev => [...prev, ...newFiles]);
  }, [defaultCategory, defaultStatus]);

  const { getRootProps, getInputProps, isDragActive } = useDropzone({
    onDrop,
    accept: {
      'video/*': ['.mp4', '.mkv', '.avi', '.mov', '.webm', '.flv']
    },
    multiple: true,
  });

  const updateQueueItem = (id, updates) => {
    setQueue(prev => prev.map(item => 
      item.id === id ? { ...item, ...updates } : item
    ));
  };

  const removeFromQueue = (id) => {
    setQueue(prev => prev.filter(item => item.id !== id));
  };

  const startUpload = async () => {
    if (queue.length === 0) return;
    
    setIsUploading(true);
    setIsPaused(false);

    for (let i = currentIndex; i < queue.length; i++) {
      if (isPaused) {
        setCurrentIndex(i);
        return;
      }

      const item = queue[i];
      if (item.status === 'success') continue;

      updateQueueItem(item.id, { status: 'uploading', progress: 0 });

      try {
        const formData = new FormData();
        formData.append('video', item.file);
        formData.append('title', item.title);
        formData.append('status', item.videoStatus);
        if (item.category) formData.append('category', item.category);

        await adminAPI.uploadVideo(formData, (progress) => {
          updateQueueItem(item.id, { progress });
        });

        updateQueueItem(item.id, { status: 'success', progress: 100 });
        toast.success(`Uploaded: ${item.title}`);
      } catch (error) {
        console.error('Upload failed:', error);
        updateQueueItem(item.id, { 
          status: 'failed', 
          error: error.response?.data?.error || 'Upload failed' 
        });
      }
    }

    setIsUploading(false);
    setCurrentIndex(0);
  };

  const pauseUpload = () => {
    setIsPaused(true);
  };

  const resumeUpload = () => {
    setIsPaused(false);
    startUpload();
  };

  const retryFailed = () => {
    setQueue(prev => prev.map(item => 
      item.status === 'failed' ? { ...item, status: 'pending', error: null } : item
    ));
  };

  const clearCompleted = () => {
    setQueue(prev => prev.filter(item => item.status !== 'success'));
  };

  const clearAll = () => {
    if (!isUploading) {
      setQueue([]);
    }
  };

  const pendingCount = queue.filter(q => q.status === 'pending').length;
  const successCount = queue.filter(q => q.status === 'success').length;
  const failedCount = queue.filter(q => q.status === 'failed').length;

  return (
    <div className="space-y-6">
      {/* Default Settings */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Default Category</label>
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Default Status</label>
          <select
            value={defaultStatus}
            onChange={(e) => setDefaultStatus(e.target.value)}
            className="input-field"
          >
            <option value="public">Public</option>
            <option value="private">Private</option>
            <option value="unlisted">Unlisted</option>
          </select>
        </div>
      </div>

      {/* Dropzone */}
      <div
        {...getRootProps()}
        className={`border-2 border-dashed rounded-xl p-12 text-center cursor-pointer transition-all ${
          isDragActive
            ? 'border-primary-500 bg-primary-500/10'
            : 'border-dark-100 hover:border-gray-600'
        }`}
      >
        <input {...getInputProps()} />
        <FiUploadCloud className="w-16 h-16 mx-auto text-gray-500 mb-4" />
        <p className="text-lg text-white mb-2">
          {isDragActive ? 'Drop videos here...' : 'Drag & drop videos here'}
        </p>
        <p className="text-gray-500">or click to browse files</p>
        <p className="text-gray-600 text-sm mt-4">
          Supports: MP4, MKV, AVI, MOV, WebM, FLV (Max 10GB each)
        </p>
      </div>

      {/* Queue Stats */}
      {queue.length > 0 && (
        <div className="flex flex-wrap items-center gap-4 p-4 bg-dark-100 rounded-lg">
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-gray-500"></span>
            <span className="text-gray-400">Pending: {pendingCount}</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-green-500"></span>
            <span className="text-gray-400">Completed: {successCount}</span>
          </div>
          <div className="flex items-center gap-2">
            <span className="w-3 h-3 rounded-full bg-red-500"></span>
            <span className="text-gray-400">Failed: {failedCount}</span>
          </div>
          
          <div className="flex-1"></div>
          
          <div className="flex gap-2">
            {failedCount > 0 && (
              <button onClick={retryFailed} className="btn-secondary text-sm">
                <FiRefreshCw className="w-4 h-4" />
                Retry Failed
              </button>
            )}
            {successCount > 0 && (
              <button onClick={clearCompleted} className="btn-secondary text-sm">
                Clear Completed
              </button>
            )}
            {!isUploading && (
              <button onClick={clearAll} className="btn-secondary text-sm">
                Clear All
              </button>
            )}
          </div>
        </div>
      )}

      {/* Upload Queue */}
      {queue.length > 0 && (
        <div className="space-y-3">
          {queue.map((item) => (
            <QueueItem
              key={item.id}
              item={item}
              categories={categories}
              onUpdate={(updates) => updateQueueItem(item.id, updates)}
              onRemove={() => removeFromQueue(item.id)}
              isUploading={isUploading}
            />
          ))}
        </div>
      )}

      {/* Start/Pause Button */}
      {queue.length > 0 && pendingCount > 0 && (
        <div className="flex justify-center gap-4">
          {!isUploading ? (
            <button onClick={startUpload} className="btn-primary px-8 py-3 text-lg">
              <FiPlay className="w-5 h-5" />
              Start Upload ({pendingCount} videos)
            </button>
          ) : isPaused ? (
            <button onClick={resumeUpload} className="btn-primary px-8 py-3 text-lg">
              <FiPlay className="w-5 h-5" />
              Resume Upload
            </button>
          ) : (
            <button onClick={pauseUpload} className="btn-secondary px-8 py-3 text-lg">
              <FiPause className="w-5 h-5" />
              Pause Upload
            </button>
          )}
        </div>
      )}
    </div>
  );
};

// Queue Item Component
const QueueItem = ({ item, categories, onUpdate, onRemove, isUploading }) => {
  const statusColors = {
    pending: 'bg-gray-500',
    uploading: 'bg-blue-500',
    success: 'bg-green-500',
    failed: 'bg-red-500',
  };

  const statusIcons = {
    pending: null,
    uploading: <div className="w-4 h-4 border-2 border-white/30 border-t-white rounded-full animate-spin" />,
    success: <FiCheck className="w-4 h-4" />,
    failed: <FiAlertCircle className="w-4 h-4" />,
  };

  return (
    <div className={`bg-dark-100 rounded-lg p-4 ${item.status === 'failed' ? 'border border-red-500/50' : ''}`}>
      <div className="flex items-start gap-4">
        {/* Status Icon */}
        <div className={`w-10 h-10 rounded-lg ${statusColors[item.status]} flex items-center justify-center text-white flex-shrink-0`}>
          {statusIcons[item.status] || <FiFile className="w-5 h-5" />}
        </div>

        {/* Content */}
        <div className="flex-1 min-w-0">
          <div className="flex items-start justify-between gap-4">
            <div className="flex-1">
              {item.status === 'pending' ? (
                <input
                  type="text"
                  value={item.title}
                  onChange={(e) => onUpdate({ title: e.target.value })}
                  className="w-full bg-transparent text-white font-medium focus:outline-none focus:bg-dark-200 px-2 py-1 rounded -ml-2"
                  placeholder="Video title"
                />
              ) : (
                <p className="text-white font-medium truncate">{item.title}</p>
              )}
              <p className="text-gray-500 text-sm">
                {(item.size / (1024 * 1024)).toFixed(2)} MB
              </p>
            </div>

            {item.status === 'pending' && (
              <select
                value={item.category}
                onChange={(e) => onUpdate({ category: e.target.value })}
                className="px-3 py-1.5 bg-dark-200 border border-dark-100 rounded text-sm text-white"
              >
                <option value="">No Category</option>
                {categories.map(cat => (
                  <option key={cat._id} value={cat._id}>{cat.name}</option>
                ))}
              </select>
            )}

            {item.status !== 'uploading' && (
              <button
                onClick={onRemove}
                className="p-2 hover:bg-dark-200 rounded text-gray-400 hover:text-red-500"
              >
                <FiX className="w-4 h-4" />
              </button>
            )}
          </div>

          {/* Progress Bar */}
          {item.status === 'uploading' && (
            <div className="mt-3">
              <div className="flex justify-between text-sm mb-1">
                <span className="text-gray-400">Uploading...</span>
                <span className="text-white">{item.progress}%</span>
              </div>
              <div className="w-full h-2 bg-dark-200 rounded-full overflow-hidden">
                <div
                  className="h-full bg-primary-500 transition-all duration-300"
                  style={{ width: `${item.progress}%` }}
                />
              </div>
            </div>
          )}

          {/* Error Message */}
          {item.status === 'failed' && item.error && (
            <p className="text-red-500 text-sm mt-2">{item.error}</p>
          )}
        </div>
      </div>
    </div>
  );
};

// ==================== FILE CODE SECTION ====================
const FileCodeSection = ({ categories }) => {
  const [fileCodes, setFileCodes] = useState([{ file_code: '', title: '' }]);
  const [defaultCategory, setDefaultCategory] = useState('');
  const [defaultStatus, setDefaultStatus] = useState('public');
  const [loading, setLoading] = useState(false);
  const [results, setResults] = useState(null);

  const addRow = () => {
    setFileCodes([...fileCodes, { file_code: '', title: '' }]);
  };

  const removeRow = (index) => {
    setFileCodes(fileCodes.filter((_, i) => i !== index));
  };

  const updateRow = (index, field, value) => {
    setFileCodes(fileCodes.map((row, i) => 
      i === index ? { ...row, [field]: value } : row
    ));
  };

  const handleSubmit = async () => {
    const validCodes = fileCodes.filter(fc => fc.file_code.trim());
    if (validCodes.length === 0) {
      toast.error('Please enter at least one file code');
      return;
    }

    setLoading(true);
    setResults(null);

    try {
      const videos = validCodes.map(fc => ({
        file_code: fc.file_code.trim(),
        title: fc.title.trim() || fc.file_code.trim(),
        category: defaultCategory || null,
        status: defaultStatus,
      }));

      const response = await adminAPI.bulkAddFileCodes(videos);
      setResults(response.data.results);
      
      // Clear successful entries
      const successCodes = response.data.results.success.map(s => s.file_code);
      setFileCodes(fileCodes.filter(fc => !successCodes.includes(fc.file_code.trim())));
      
      if (response.data.results.success.length > 0) {
        toast.success(`Added ${response.data.results.success.length} videos`);
      }
      if (response.data.results.failed.length > 0) {
        toast.error(`${response.data.results.failed.length} failed`);
      }
    } catch (error) {
      toast.error('Failed to add videos');
    } finally {
      setLoading(false);
    }
  };

  const handlePaste = (e) => {
    const pastedText = e.clipboardData.getData('text');
    const lines = pastedText.split('\n').filter(line => line.trim());
    
    if (lines.length > 1) {
      e.preventDefault();
      const newCodes = lines.map(line => {
        const parts = line.split(/[\t,]/);
        return {
          file_code: parts[0]?.trim() || '',
          title: parts[1]?.trim() || '',
        };
      });
      setFileCodes([...fileCodes.filter(fc => fc.file_code), ...newCodes]);
    }
  };

  return (
    <div className="space-y-6">
      {/* Instructions */}
      <div className="bg-dark-100 rounded-lg p-4">
        <p className="text-gray-300 text-sm">
          Enter Abyss.to file codes to add videos to your platform. You can paste multiple codes (one per line) or with titles (code, title format).
        </p>
      </div>

      {/* Default Settings */}
      <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Category</label>
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
        </div>
        <div>
          <label className="block text-sm font-medium text-gray-300 mb-2">Status</label>
          <select
            value={defaultStatus}
            onChange={(e) => setDefaultStatus(e.target.value)}
            className="input-field"
          >
            <option value="public">Public</option>
            <option value="private">Private</option>
            <option value="unlisted">Unlisted</option>
          </select>
        </div>
      </div>

      {/* File Code Inputs */}
      <div className="space-y-3">
        {fileCodes.map((row, index) => (
          <div key={index} className="flex gap-3">
            <input
              type="text"
              value={row.file_code}
              onChange={(e) => updateRow(index, 'file_code', e.target.value)}
              onPaste={index === 0 ? handlePaste : undefined}
              placeholder="File code (e.g., abc123xyz)"
              className="input-field flex-1"
            />
            <input
              type="text"
              value={row.title}
              onChange={(e) => updateRow(index, 'title', e.target.value)}
              placeholder="Title (optional)"
              className="input-field flex-1"
            />
            <button
              onClick={() => removeRow(index)}
              className="p-3 hover:bg-dark-100 rounded-lg text-gray-400 hover:text-red-500"
              disabled={fileCodes.length === 1}
            >
              <FiX className="w-5 h-5" />
            </button>
          </div>
        ))}
      </div>

      {/* Add Row Button */}
      <button onClick={addRow} className="btn-secondary w-full">
        <FiPlus className="w-5 h-5" />
        Add Another
      </button>

      {/* Submit Button */}
      <button
        onClick={handleSubmit}
        disabled={loading}
        className="btn-primary w-full py-3"
      >
        {loading ? 'Adding Videos...' : `Add ${fileCodes.filter(fc => fc.file_code.trim()).length} Videos`}
      </button>

      {/* Results */}
      {results && (
        <div className="space-y-4">
          {results.success.length > 0 && (
            <div className="bg-green-500/10 border border-green-500/20 rounded-lg p-4">
              <h4 className="text-green-500 font-medium mb-2">
                Successfully Added ({results.success.length})
              </h4>
              <div className="space-y-1 text-sm text-green-400">
                {results.success.map((s, i) => (
                  <p key={i}>{s.file_code}</p>
                ))}
              </div>
            </div>
          )}
          {results.failed.length > 0 && (
            <div className="bg-red-500/10 border border-red-500/20 rounded-lg p-4">
              <h4 className="text-red-500 font-medium mb-2">
                Failed ({results.failed.length})
              </h4>
              <div className="space-y-1 text-sm">
                {results.failed.map((f, i) => (
                  <p key={i} className="text-red-400">
                    {f.file_code}: {f.error}
                  </p>
                ))}
              </div>
            </div>
          )}
        </div>
      )}
    </div>
  );
};

// ==================== ABYSS FILES SECTION ====================
const AbyssFilesSection = ({ categories }) => {
  const [files, setFiles] = useState([]);
  const [loading, setLoading] = useState(true);
  const [selectedFiles, setSelectedFiles] = useState([]);
  const [importing, setImporting] = useState(false);
  const [page, setPage] = useState(1);
  const [pagination, setPagination] = useState({ total: 0 });
  const [defaultCategory, setDefaultCategory] = useState('');

  useEffect(() => {
    fetchAbyssFiles();
  }, [page]);

  const fetchAbyssFiles = async () => {
    setLoading(true);
    try {
      const response = await adminAPI.getAbyssFiles(page, 50);
      if (response.data.success) {
        setFiles(response.data.files);
        setPagination(response.data.pagination);
      }
    } catch (error) {
      toast.error('Failed to fetch files from Abyss');
    } finally {
      setLoading(false);
    }
  };

  const handleSelectFile = (fileCode) => {
    setSelectedFiles(prev =>
      prev.includes(fileCode)
        ? prev.filter(fc => fc !== fileCode)
        : [...prev, fileCode]
    );
  };

  const handleSelectAll = () => {
    const notAdded = files.filter(f => !f.alreadyAdded).map(f => f.file_code);
    if (selectedFiles.length === notAdded.length) {
      setSelectedFiles([]);
    } else {
      setSelectedFiles(notAdded);
    }
  };

  const handleImport = async () => {
    if (selectedFiles.length === 0) return;

    setImporting(true);
    try {
      const videos = selectedFiles.map(file_code => {
        const file = files.find(f => f.file_code === file_code);
        return {
          file_code,
          title: file?.title || file_code,
          category: defaultCategory || null,
        };
      });

      const response = await adminAPI.bulkAddFileCodes(videos);
      
      // Update files list
      const successCodes = response.data.results.success.map(s => s.file_code);
      setFiles(files.map(f => 
        successCodes.includes(f.file_code) ? { ...f, alreadyAdded: true } : f
      ));
      setSelectedFiles([]);
      
      toast.success(`Imported ${response.data.results.success.length} videos`);
    } catch (error) {
      toast.error('Failed to import videos');
    } finally {
      setImporting(false);
    }
  };

  if (loading) {
    return <LoadingSpinner />;
  }

  return (
    <div className="space-y-6">
      {/* Category Selection */}
      <div className="flex items-center justify-between gap-4 flex-wrap">
        <div className="flex items-center gap-4">
          <select
            value={defaultCategory}
            onChange={(e) => setDefaultCategory(e.target.value)}
            className="input-field w-48"
          >
            <option value="">No Category</option>
            {categories.map(cat => (
              <option key={cat._id} value={cat._id}>{cat.name}</option>
            ))}
          </select>
          
          <button onClick={handleSelectAll} className="btn-secondary">
            Select All Available
          </button>
        </div>

        {selectedFiles.length > 0 && (
          <button
            onClick={handleImport}
            disabled={importing}
            className="btn-primary"
          >
            {importing ? 'Importing...' : `Import ${selectedFiles.length} Videos`}
          </button>
        )}
      </div>

      {/* Files Grid */}
      <div className="grid grid-cols-2 sm:grid-cols-3 md:grid-cols-4 lg:grid-cols-5 gap-4">
        {files.map((file) => (
          <div
            key={file.file_code}
            onClick={() => !file.alreadyAdded && handleSelectFile(file.file_code)}
            className={`relative rounded-lg overflow-hidden cursor-pointer transition-all ${
              file.alreadyAdded 
                ? 'opacity-50 cursor-not-allowed' 
                : selectedFiles.includes(file.file_code)
                  ? 'ring-2 ring-primary-500'
                  : 'hover:ring-2 hover:ring-gray-500'
            }`}
          >
            <div className="aspect-video bg-dark-100">
              <img
                src={`https://abyss.to/thumb/${file.file_code}.jpg`}
                alt={file.title}
                className="w-full h-full object-cover"
                onError={(e) => {
  e.target.src =
    "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iMzIwIiBoZWlnaHQ9IjE4MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWUxZTFlIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIxNiIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIFRodW1ibmFpbDwvdGV4dD48L3N2Zz4=";
}}

              />
            </div>
            
            {/* Selection Overlay */}
            {selectedFiles.includes(file.file_code) && (
              <div className="absolute inset-0 bg-primary-500/30 flex items-center justify-center">
                <div className="w-8 h-8 bg-primary-500 rounded-full flex items-center justify-center">
                  <FiCheck className="w-5 h-5 text-white" />
                </div>
              </div>
            )}

            {/* Already Added Badge */}
            {file.alreadyAdded && (
              <div className="absolute top-2 right-2 bg-green-500 text-white text-xs px-2 py-1 rounded">
                Added
              </div>
            )}

            <div className="p-2">
              <p className="text-white text-sm truncate">{file.title || file.file_code}</p>
              <p className="text-gray-500 text-xs">{file.file_code}</p>
            </div>
          </div>
        ))}
      </div>

      {/* Pagination */}
      <div className="flex justify-center gap-2">
        <button
          onClick={() => setPage(p => Math.max(1, p - 1))}
          disabled={page === 1}
          className="btn-secondary"
        >
          Previous
        </button>
        <span className="px-4 py-2 text-gray-400">
          Page {page}
        </span>
        <button
          onClick={() => setPage(p => p + 1)}
          disabled={files.length < 50}
          className="btn-secondary"
        >
          Next
        </button>
      </div>
    </div>
  );
};

export default UploadPage;

frontend/src/pages/admin/Dashboard.jsx

import React, { useState, useEffect } from 'react';
import { Link } from 'react-router-dom';
import { 
  FiVideo, FiEye, FiTrendingUp, FiUpload, 
  FiGrid, FiDollarSign, FiFlag, FiArrowRight 
} from 'react-icons/fi';
import { AreaChart, Area, XAxis, YAxis, CartesianGrid, Tooltip, ResponsiveContainer } from 'recharts';
import { adminAPI } from '../../services/api';
import AdminLayout from '../../components/admin/AdminLayout';
import StatsCard from '../../components/admin/StatsCard';
import LoadingSpinner from '../../components/common/LoadingSpinner';
import { formatViews, formatDate } from '../../utils/helpers';

const Dashboard = () => {
  const [data, setData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const fetchDashboard = async () => {
      try {
        const response = await adminAPI.getDashboard();
        if (response.data.success) {
          setData(response.data);
        }
      } catch (error) {
        console.error('Failed to fetch dashboard:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchDashboard();
  }, []);

  if (loading) {
    return (
      <AdminLayout title="Dashboard">
        <LoadingSpinner />
      </AdminLayout>
    );
  }

  const stats = data?.stats || {};
  const topVideos = data?.topVideos || [];
  const recentUploads = data?.recentUploads || [];
  const viewsByDay = data?.viewsByDay || [];

  return (
    <AdminLayout title="Dashboard">
      {/* Stats Grid */}
      <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-4 gap-4 mb-8">
        <StatsCard
          title="Total Videos"
          value={stats.totalVideos || 0}
          icon={FiVideo}
          color="primary"
        />
        <StatsCard
          title="Total Views"
          value={formatViews(stats.totalViews || 0)}
          icon={FiEye}
          color="blue"
        />
        <StatsCard
          title="This Week"
          value={stats.weekVideos || 0}
          icon={FiTrendingUp}
          change="videos uploaded"
          color="green"
        />
        <StatsCard
          title="Pending Reports"
          value={stats.pendingReports || 0}
          icon={FiFlag}
          color="yellow"
        />
      </div>

      <div className="grid grid-cols-1 lg:grid-cols-3 gap-6">
        {/* Chart */}
        <div className="lg:col-span-2 bg-dark-200 rounded-xl p-6 border border-dark-100">
          <h3 className="text-lg font-semibold text-white mb-6">Views & Uploads (Last 7 Days)</h3>
          <div className="h-80">
            <ResponsiveContainer width="100%" height="100%">
              <AreaChart data={viewsByDay}>
                <defs>
                  <linearGradient id="colorViews" x1="0" y1="0" x2="0" y2="1">
                    <stop offset="5%" stopColor="#ef4444" stopOpacity={0.3}/>
                    <stop offset="95%" stopColor="#ef4444" stopOpacity={0}/>
                  </linearGradient>
                </defs>
                <CartesianGrid strokeDasharray="3 3" stroke="#333" />
                <XAxis dataKey="_id" stroke="#666" fontSize={12} />
                <YAxis stroke="#666" fontSize={12} />
                <Tooltip 
                  contentStyle={{ 
                    backgroundColor: '#1e1e1e', 
                    border: '1px solid #333',
                    borderRadius: '8px'
                  }}
                />
                <Area 
                  type="monotone" 
                  dataKey="views" 
                  stroke="#ef4444" 
                  fillOpacity={1} 
                  fill="url(#colorViews)" 
                />
              </AreaChart>
            </ResponsiveContainer>
          </div>
        </div>

        {/* Quick Actions */}
        <div className="bg-dark-200 rounded-xl p-6 border border-dark-100">
          <h3 className="text-lg font-semibold text-white mb-6">Quick Actions</h3>
          <div className="space-y-3">
            <Link
              to="/admin/upload"
              className="flex items-center justify-between p-4 bg-dark-100 hover:bg-dark-300 rounded-lg transition-colors group"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-primary-500/20 rounded-lg flex items-center justify-center">
                  <FiUpload className="w-5 h-5 text-primary-500" />
                </div>
                <span className="text-white font-medium">Upload Videos</span>
              </div>
              <FiArrowRight className="w-5 h-5 text-gray-500 group-hover:text-white transition-colors" />
            </Link>

            <Link
              to="/admin/videos"
              className="flex items-center justify-between p-4 bg-dark-100 hover:bg-dark-300 rounded-lg transition-colors group"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-blue-500/20 rounded-lg flex items-center justify-center">
                  <FiVideo className="w-5 h-5 text-blue-500" />
                </div>
                <span className="text-white font-medium">Manage Videos</span>
              </div>
              <FiArrowRight className="w-5 h-5 text-gray-500 group-hover:text-white transition-colors" />
            </Link>

            <Link
              to="/admin/categories"
              className="flex items-center justify-between p-4 bg-dark-100 hover:bg-dark-300 rounded-lg transition-colors group"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-green-500/20 rounded-lg flex items-center justify-center">
                  <FiGrid className="w-5 h-5 text-green-500" />
                </div>
                <span className="text-white font-medium">Categories</span>
              </div>
              <FiArrowRight className="w-5 h-5 text-gray-500 group-hover:text-white transition-colors" />
            </Link>

            <Link
              to="/admin/ads"
              className="flex items-center justify-between p-4 bg-dark-100 hover:bg-dark-300 rounded-lg transition-colors group"
            >
              <div className="flex items-center gap-3">
                <div className="w-10 h-10 bg-yellow-500/20 rounded-lg flex items-center justify-center">
                  <FiDollarSign className="w-5 h-5 text-yellow-500" />
                </div>
                <span className="text-white font-medium">Manage Ads</span>
              </div>
              <FiArrowRight className="w-5 h-5 text-gray-500 group-hover:text-white transition-colors" />
            </Link>
          </div>
        </div>
      </div>

      {/* Recent & Top Videos */}
      <div className="grid grid-cols-1 lg:grid-cols-2 gap-6 mt-6">
        {/* Top Videos */}
        <div className="bg-dark-200 rounded-xl p-6 border border-dark-100">
          <h3 className="text-lg font-semibold text-white mb-4">Top Performing Videos</h3>
          <div className="space-y-3">
            {topVideos.map((video, index) => (
              <div key={video._id} className="flex items-center gap-3">
                <span className="w-6 h-6 bg-primary-500/20 text-primary-500 rounded-full flex items-center justify-center text-sm font-medium">
                  {index + 1}
                </span>
                <img 
                  src={video.thumbnail} 
                  alt={video.title}
                  className="w-16 h-10 object-cover rounded"
                />
                <div className="flex-1 min-w-0">
                  <p className="text-white text-sm font-medium truncate">{video.title}</p>
                  <p className="text-gray-500 text-xs">{formatViews(video.views)} views</p>
                </div>
              </div>
            ))}
          </div>
        </div>

        {/* Recent Uploads */}
        <div className="bg-dark-200 rounded-xl p-6 border border-dark-100">
          <h3 className="text-lg font-semibold text-white mb-4">Recent Uploads</h3>
          <div className="space-y-3">
            {recentUploads.map((video) => (
              <div key={video._id} className="flex items-center gap-3">
                <img 
                  src={video.thumbnail} 
                  alt={video.title}
                  className="w-16 h-10 object-cover rounded"
                />
                <div className="flex-1 min-w-0">
                  <p className="text-white text-sm font-medium truncate">{video.title}</p>
                  <p className="text-gray-500 text-xs">{formatDate(video.uploadDate)}</p>
                </div>
                <span className={`badge ${
                  video.status === 'public' ? 'badge-success' : 'badge-warning'
                }`}>
                  {video.status}
                </span>
              </div>
            ))}
          </div>
        </div>
      </div>
    </AdminLayout>
  );
};

export default Dashboard;

frontend/src/services/api.js

import axios from 'axios';

const API_URL = process.env.REACT_APP_API_URL || "https://xmaster-website.onrender.com/api";


// Create axios instance
const api = axios.create({
  baseURL: API_URL,
  headers: {
    'Content-Type': 'application/json',
  },
});

// Request interceptor - add auth token
api.interceptors.request.use(
  (config) => {
    const token = localStorage.getItem('adminToken');
    if (token) {
      config.headers.Authorization = `Bearer ${token}`;
    }
    return config;
  },
  (error) => {
    return Promise.reject(error);
  }
);

// Response interceptor - handle errors
api.interceptors.response.use(
  (response) => response,
  (error) => {
    if (error.response?.status === 401) {
      localStorage.removeItem('adminToken');
      // Only redirect if on admin page
      if (window.location.pathname.startsWith('/admin')) {
        window.location.href = '/xmaster-admin';
      }
    }
    return Promise.reject(error);
  }
);

// ==================== PUBLIC API ====================

export const publicAPI = {
  // Home data
  getHomeData: () => api.get('/public/home'),
  
  // Videos
  getVideos: (params) => api.get('/videos', { params }),
  getVideo: (id) => api.get(`/videos/${id}`),
  getLatestVideos: (limit = 12) => api.get('/videos/latest', { params: { limit } }),
  getTrendingVideos: (limit = 12, period = '7d') => 
    api.get('/videos/trending', { params: { limit, period } }),
  getFeaturedVideos: (limit = 6) => api.get('/videos/featured', { params: { limit } }),
  getRelatedVideos: (id, limit = 10) => api.get(`/videos/${id}/related`, { params: { limit } }),
  getRandomVideos: (limit = 10, exclude = '') => 
    api.get('/videos/random', { params: { limit, exclude } }),
  
  // Video actions
  recordView: (id, sessionId) => api.post(`/videos/${id}/view`, { sessionId }),
  likeVideo: (id) => api.post(`/videos/${id}/like`),
  dislikeVideo: (id) => api.post(`/videos/${id}/dislike`),
  reportVideo: (id, data) => api.post(`/videos/${id}/report`, data),
  
  // Categories
  getCategories: () => api.get('/categories'),
  getCategory: (slug) => api.get(`/categories/${slug}`),
  getCategoryVideos: (slug, params) => api.get(`/categories/${slug}/videos`, { params }),
  
  // Search
  searchVideos: (params) => api.get('/search', { params }),
  getSearchSuggestions: (q) => api.get('/search/suggestions', { params: { q } }),
  searchByTag: (tag, params) => api.get(`/search/tags/${tag}`, { params }),
  getPopularTags: (limit = 20) => api.get('/search/popular-tags', { params: { limit } }),
  
  // Ads
  getAds: (device = 'desktop') => api.get('/ads', { params: { device } }),
  getAdByPlacement: (placement, device = 'desktop') => 
    api.get(`/ads/placement/${placement}`, { params: { device } }),
  recordAdImpression: (id) => api.post(`/ads/${id}/impression`),
  recordAdClick: (id) => api.post(`/ads/${id}/click`),
  
  // Stats
  getPublicStats: () => api.get('/public/stats'),
};

// ==================== ADMIN API ====================

export const adminAPI = {
  // Auth
  login: (password, username = 'admin') => 
    api.post('/admin/login', { password, username }),
  verifyToken: () => api.post('/admin/verify'),
  changePassword: (currentPassword, newPassword) => 
    api.post('/admin/change-password', { currentPassword, newPassword }),
  
  // Dashboard
  getDashboard: () => api.get('/admin/dashboard'),
  
  // Videos
  getVideos: (params) => api.get('/admin/videos', { params }),
  getVideo: (id) => api.get(`/admin/videos/${id}`),
  updateVideo: (id, data) => api.put(`/admin/videos/${id}`, data),
  deleteVideo: (id) => api.delete(`/admin/videos/${id}`),
  bulkDeleteVideos: (ids) => api.post('/admin/videos/bulk-delete', { ids }),
  toggleFeatured: (id) => api.put(`/admin/videos/${id}/feature`),
  updateVideoStatus: (id, status) => api.put(`/admin/videos/${id}/status`, { status }),
  
  // Upload
  uploadVideo: (formData, onProgress) => 
    api.post('/upload/single', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
      onUploadProgress: (e) => onProgress && onProgress(Math.round((e.loaded * 100) / e.total)),
    }),
  addByFileCode: (data) => api.post('/upload/file-code', data),
  bulkAddFileCodes: (videos) => api.post('/upload/bulk-file-codes', { videos }),
  uploadThumbnail: (formData) => 
    api.post('/upload/thumbnail', formData, {
      headers: { 'Content-Type': 'multipart/form-data' },
    }),
  remoteUpload: (url, title, category, tags) => 
    api.post('/upload/url', { url, title, category, tags }),
  getAbyssFiles: (page = 1, limit = 50) => 
    api.get('/upload/abyss-files', { params: { page, limit } }),
  getAccountInfo: () => api.get('/upload/account-info'),
  
  // Categories
  createCategory: (data) => api.post('/categories', data),
  updateCategory: (id, data) => api.put(`/categories/${id}`, data),
  deleteCategory: (id) => api.delete(`/categories/${id}`),
  reorderCategories: (order) => api.put('/categories/admin/reorder', { order }),
  
  // Ads
  getAllAds: () => api.get('/ads/admin/all'),
  getAdPlacements: () => api.get('/ads/admin/placements'),
  createAd: (data) => api.post('/ads', data),
  updateAd: (id, data) => api.put(`/ads/${id}`, data),
  deleteAd: (id) => api.delete(`/ads/${id}`),
  toggleAd: (id) => api.put(`/ads/${id}/toggle`),
  
  // Analytics
  getAnalyticsDashboard: () => api.get('/analytics/dashboard'),
  getViewAnalytics: (period = '7d') => api.get('/analytics/views', { params: { period } }),
  getTopVideos: (limit = 10, period = '7d') => 
    api.get('/analytics/top-videos', { params: { limit, period } }),
  getCategoryAnalytics: () => api.get('/analytics/categories'),
  getAdAnalytics: () => api.get('/analytics/ads'),
  
  // Reports
  getReports: (params) => api.get('/analytics/reports', { params }),
  updateReport: (id, data) => api.put(`/analytics/reports/${id}`, data),
};

export default api;

frontend/public/index.html

<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="theme-color" content="#0f0f0f" />
    <meta name="description" content="Xmaster - Watch Videos Online. Your ultimate destination for entertainment." />

    <link rel="preload" as="image" href="data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWUxZTFlIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIFRodW1ibmFpbDwvdGV4dD48L3N2Zz4=">
    
    <!-- Open Graph / Social Media -->
    <meta property="og:type" content="website" />
    <meta property="og:title" content="Xmaster - Watch Videos Online" />
    <meta property="og:description" content="Your ultimate destination for entertainment." />
    <meta property="og:image" content="%PUBLIC_URL%/og-image.png" />
    
    <!-- Twitter -->
    <meta name="twitter:card" content="summary_large_image" />
    <meta name="twitter:title" content="Xmaster - Watch Videos Online" />
    <meta name="twitter:description" content="Your ultimate destination for entertainment." />
    
    <!-- Fonts -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap" rel="stylesheet">
    
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    
    <title>Xmaster - Watch Videos Online</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
  </body>
</html>

frontend/src/components/video/VideoCard.jsx

import React, { useState } from "react";
import { Link } from "react-router-dom";
import { FiEye, FiClock } from "react-icons/fi";

// Format view count (1000 -> 1K, 1000000 -> 1M)
const formatViews = (views) => {
  if (!views) return "0";
  if (views >= 1000000)
    return (views / 1000000).toFixed(1).replace(/\.0$/, "") + "M";
  if (views >= 1000)
    return (views / 1000).toFixed(1).replace(/\.0$/, "") + "K";
  return views.toString();
};

// Format date to relative time
const formatDate = (date) => {
  if (!date) return "Unknown Date";

  const now = new Date();
  const past = new Date(date);

  if (isNaN(past.getTime())) return "Unknown Date";

  const diffInSeconds = Math.floor((now - past) / 1000);

  if (diffInSeconds < 60) return "Just now";
  const diffInMinutes = Math.floor(diffInSeconds / 60);
  if (diffInMinutes < 60) return `${diffInMinutes}m ago`;
  const diffInHours = Math.floor(diffInMinutes / 60);
  if (diffInHours < 24) return `${diffInHours}h ago`;
  const diffInDays = Math.floor(diffInHours / 24);
  if (diffInDays < 7) return `${diffInDays}d ago`;
  const diffInWeeks = Math.floor(diffInDays / 7);
  if (diffInWeeks < 4) return `${diffInWeeks}w ago`;
  const diffInMonths = Math.floor(diffInDays / 30);
  if (diffInMonths < 12) return `${diffInMonths}mo ago`;
  return `${Math.floor(diffInDays / 365)}y ago`;
};

// Format duration
const formatDuration = (duration) => {
  if (!duration) return "00:00";
  if (typeof duration === "string" && duration.includes(":")) return duration;
  return "00:00";
};

// Default placeholder image
const PLACEHOLDER_IMAGE =
  "data:image/svg+xml;base64,PHN2ZyB3aWR0aD0iNjQwIiBoZWlnaHQ9IjM2MCIgeG1sbnM9Imh0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnIj48cmVjdCB3aWR0aD0iMTAwJSIgaGVpZ2h0PSIxMDAlIiBmaWxsPSIjMWUxZTFlIi8+PHRleHQgeD0iNTAlIiB5PSI1MCUiIGZvbnQtZmFtaWx5PSJBcmlhbCIgZm9udC1zaXplPSIyNCIgZmlsbD0iIzY2NiIgdGV4dC1hbmNob3I9Im1pZGRsZSIgZHk9Ii4zZW0iPk5vIFRodW1ibmFpbDwvdGV4dD48L3N2Zz4=";

const VideoCard = ({ video, size = "normal" }) => {
  const [imageError, setImageError] = useState(false);

  if (!video) return null;

  const {
    _id,
    title,
    thumbnail,
    views,
    duration,
    uploadDate,
    createdAt,
    category,
    slug,
  } = video;

  const realViews = views ?? video.viewCount ?? 0;
  const realDate = uploadDate || createdAt;
  const realDuration = duration ?? video.videoDuration ?? video.length ?? "00:00";

  const sizes = {
    small: { title: "text-sm line-clamp-2", meta: "text-xs" },
    normal: { title: "text-base line-clamp-2", meta: "text-sm" },
    large: { title: "text-lg line-clamp-2", meta: "text-sm" },
  };

  const currentSize = sizes[size] || sizes.normal;

  // âœ… FIXED: thumbnail URL generator
  const getThumbnailUrl = () => {
    if (imageError) return PLACEHOLDER_IMAGE;

    if (thumbnail && thumbnail.length > 3) {
      // Already full url
      if (thumbnail.startsWith("http")) return thumbnail;

      // If backend sends img.abyss.to/preview/xxx.jpg
      if (thumbnail.startsWith("img.")) return `https://${thumbnail}`;

      // If backend sends only filename like CbUzI8W96.jpg
      if (thumbnail.endsWith(".jpg") || thumbnail.endsWith(".png")) {
        return `https://img.abyss.to/preview/${thumbnail}`;
      }

      // If backend sends file_code without extension
      return `https://img.abyss.to/preview/${thumbnail}.jpg`;
    }

    return PLACEHOLDER_IMAGE;
  };

  const handleImageError = () => {
    setImageError(true);
  };

  return (
    <Link
      to={`/watch/${_id}${slug ? `/${slug}` : ""}`}
      className="group block w-full"
    >
      <div className="bg-white dark:bg-dark-200 rounded-xl shadow-lg overflow-hidden transition-all duration-300 hover:shadow-xl hover:scale-[1.02] cursor-pointer">
        {/* Thumbnail */}
        <div className="relative aspect-video bg-gray-800 overflow-hidden">
          <img
            src={getThumbnailUrl()}
            alt={title || "Video thumbnail"}
            className="w-full h-full object-cover group-hover:scale-105 transition-transform duration-300"
            loading="lazy"
            onError={handleImageError}
          />

          {/* Duration Badge */}
          {realDuration && realDuration !== "00:00" && (
            <div className="absolute bottom-2 right-2 px-2 py-1 bg-black/80 rounded text-white text-xs font-medium flex items-center gap-1">
              <FiClock className="w-3 h-3" />
              {formatDuration(realDuration)}
            </div>
          )}

          {/* Hover Overlay */}
          <div className="absolute inset-0 bg-black/0 group-hover:bg-black/20 transition-colors duration-300 flex items-center justify-center">
            <div className="w-16 h-16 rounded-full bg-red-600/90 flex items-center justify-center opacity-0 group-hover:opacity-100 transform scale-75 group-hover:scale-100 transition-all duration-300">
              <svg
                className="w-8 h-8 text-white ml-1"
                fill="currentColor"
                viewBox="0 0 20 20"
              >
                <path d="M6.3 2.841A1.5 1.5 0 004 4.11V15.89a1.5 1.5 0 002.3 1.269l9.344-5.89a1.5 1.5 0 000-2.538L6.3 2.84z" />
              </svg>
            </div>
          </div>
        </div>

        {/* Info */}
        <div className="p-3">
          <h3
            className={`font-medium text-gray-900 dark:text-white group-hover:text-red-600 dark:group-hover:text-red-500 transition-colors ${currentSize.title}`}
          >
            {title || "Untitled Video"}
          </h3>

          <div
            className={`mt-2 flex items-center gap-3 text-gray-500 dark:text-gray-400 ${currentSize.meta}`}
          >
            {/* Views */}
            <span className="flex items-center gap-1">
              <FiEye className="w-3.5 h-3.5" />
              {formatViews(realViews)} views
            </span>

            {/* Date */}
            <span>â€¢</span>
            <span>{formatDate(realDate)}</span>
          </div>

          {/* âœ… Category Fix (string category) */}
          {category && (
            <div className="mt-2">
              <span className="text-xs px-2 py-1 bg-gray-100 dark:bg-dark-100 text-gray-600 dark:text-gray-400 rounded-full">
                {typeof category === "string" ? category : category.name}
              </span>
            </div>
          )}
        </div>
      </div>
    </Link>
  );
};

export default VideoCard;


Environment:
backend/.env.example (just the key names)


# Abyss.to API Configuration (REQUIRED)
ABYSS_API_KEY=2ce5472bb6faa900b747eeaf65012a18
ABYSS_API_BASE_URL=https://api.abyss.to

# Server Configuration
PORT=5000
NODE_ENV=production

# Frontend URL (for CORS) - PRODUCTION
# For multiple origins, separate with commas
# Example: https://your-app.netlify.app,http://localhost:3000
FRONTEND_URL=https://your-app.netlify.app,http://localhost:3000

# Database Configuration (if using real database instead of in-memory)
# MONGODB_URI=mongodb+srv://username:password@cluster.mongodb.net/video-platform
# DATABASE_URL=postgres://username:password@host:port/database
